<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>jihoon.me</title><description>This is a personal blog for iOS Developer jihoonahn.</description><link>https://blog.jihoon.me</link><language>ko</language><lastBuildDate>Wed, 13 Dec 2023 13:11:01 +0000</lastBuildDate><pubDate>Wed, 13 Dec 2023 13:11:01 +0000</pubDate><ttl>250</ttl><atom:link href="https://blog.jihoon.me/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://blog.jihoon.me/blog/publish-part-3</guid><title>Publish 사용하기 part 3</title><description>Swift publish 배포하기</description><link>https://blog.jihoon.me/blog/publish-part-3</link><pubDate>Sat, 18 Nov 2023 15:48:00 +0000</pubDate><content:encoded><![CDATA[<h2>Publish 배포 준비하기</h2><p>일단 배포 준비를 하기 위해서는 publish pipeline에서 수정할 부분이 있습니다.</p><pre><code><span class="comment">// This will generate your website using the built-in Foundation theme:</span>
<span class="keyword">try</span> <span class="type">Example</span>().<span class="call">publish</span>(using: [
    .<span class="call">optional</span>(.<span class="call">copyResources</span>()),
    .<span class="call">addMarkdownFiles</span>(),
    .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">publish</span>),
    .<span class="call">generateRSSFeed</span>(including: [.<span class="dotAccess">blog</span>]),
    .<span class="call">generateSiteMap</span>(),
    <span class="comment">/// Deploy 관련</span>
    .<span class="call">deploy</span>(using: <span class="comment">///배포 방식 )</span>
])
</code></pre><p>기존에 만든 pipeline에서 <code>deploy(using:)</code> 메서드를 추가해줍니다.</p><pre><code><span class="keyword">static func</span> gitHub(
    <span class="keyword">_</span> repository: <span class="type">String</span>,
    branch: <span class="type">String</span> = <span class="string">"master"</span>,
    useSSH: <span class="type">Bool</span> = <span class="keyword">true</span>
) -&gt; <span class="type">DeploymentMethod</span>&lt;<span class="type">Example</span>&gt;
</code></pre><ul><li>repository: 프로젝트 Repository</li><li>branch: 배포할 Branch</li><li>useSSH: SSH 키를 사용하는지 여부</li></ul><pre><code>.<span class="call">deploy</span>(using: .<span class="call">git</span>(<span class="string">"git@ios.github.com:jihoonahn/ExamplePublish"</span>, branch: <span class="string">"gh-pages"</span>))
</code></pre><p>저는 ssh키를 여러개를 사용하는 관계로 그냥 git으로 작성 하였습니다.</p><p>그리고 Website 부분에서</p><pre><code><span class="keyword">struct</span> Example: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="keyword">case</span> blog
        <span class="keyword">case</span> about
        <span class="keyword">var</span> name: <span class="type">String</span> {
            <span class="keyword">switch self</span> {
            <span class="keyword">case</span> .<span class="dotAccess">blog</span>: <span class="keyword">return</span> <span class="string">"Blog"</span>
            <span class="keyword">case</span> .<span class="dotAccess">about</span>: <span class="keyword">return</span> <span class="string">"About"</span>
            }
        }
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
        <span class="comment">// Add any site-specific metadata that you want to use here.</span>
    }

    <span class="comment">// Update these properties to configure your website:</span>
    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="comment">/* URL 값 입력 */</span> )!
    <span class="keyword">var</span> name = <span class="string">"Example"</span>
    <span class="keyword">var</span> description = <span class="string">"A description of Part"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
}
</code></pre><p>URL 값을 입력해줍니다.</p><pre><code><span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://jihoonahn.github.io/"</span>)!
</code></pre><p>Publish CLI를 보게 되면</p><pre><code><span class="type">Publish Command Line Interface</span>
------------------------------
<span class="type">Interact</span> with the <span class="type">Publish</span> <span class="keyword">static</span> site generator from
the command line, to create new websites, or to generate
and deploy existing ones.

<span class="type">Available</span> commands:

- new: <span class="type">Set</span> up a new website <span class="keyword">in</span> the current folder.
- generate: <span class="type">Generate</span> the website <span class="keyword">in</span> the current folder.
- run: <span class="type">Generate</span> and run a localhost server on <span class="keyword">default</span> port <span class="number">8000</span>
       <span class="keyword">for</span> the website <span class="keyword">in</span> the current folder. <span class="type">Use</span> the <span class="string">"-p"</span>
       or <span class="string">"--port"</span> option <span class="keyword">for</span> customizing the <span class="keyword">default</span> port.
- deploy: <span class="type">Generate</span> and deploy the website <span class="keyword">in</span> the current
       folder, according to its deployment method.
</code></pre><p>이런식으로 deploy 관련 커맨드가 있습니다.</p><pre><code>$ publish generate
$ publish deploy
</code></pre><p>이렇게 명령어를 순차적으로 작성하게 되면,</p><img width = 100% src="https://github.com/jihoonahn/blog/assets/68891494/20ec7f25-7aeb-441a-9ca7-240b39c7d1ca"></img><p>이렇게 Deploy가 완료가 됬다는 내용과 함께</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/696fd9de-df43-4b1d-8581-422e077698e0"></img><ul><li>❌ 포스트 올라간 후에 삭제될 Repository입니다.</li></ul><p>이렇게 gh-pages에 잘 배포가 되는것을 확인 할 수 있습니다.</p><p>위에서 진행한 내용은 <a href="https://github.com/Jihoonahn/Blog-Document/tree/main/Publish/part3">예시코드</a> 를 확인할 수 있습니다.</p><hr><p>이번 글에서는 Publish에서 Deploy 하는 방법에 대해서 알아보면서, 총 publish를 사용하는 방법에 대해서 3개로 파트를 나눠서 제작을 하였습니다. 여러분도 한번 Publish로 자기만의 blog를 만들어 보는것은 어떤가요?</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/publish-part-2</guid><title>Publish 사용하기 part 2</title><description>Swift publish 커스텀하기</description><link>https://blog.jihoon.me/blog/publish-part-2</link><pubDate>Thu, 26 Oct 2023 14:48:00 +0000</pubDate><content:encoded><![CDATA[<h2>Publish 구조 작성하기</h2><pre><code><span class="keyword">struct</span> PublishHTMLFactory: <span class="type">HTMLFactory</span> {
    <span class="keyword">typealias</span> Site = <span class="type">Example</span>

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Publish</span>.<span class="type">Index</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Publish</span>.<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Publish</span>.<span class="type">Page</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">Publish</span>.<span class="type">TagListPage</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span>? {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">Publish</span>.<span class="type">TagDetailsPage</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span>? {
        &lt;#code#&gt;
    }
}
</code></pre><p>이전 포스트에서 만든 <code>PublishHTMLFactory</code> 부분 부터 보도록 하겠습니다.</p><p>Publish에서 HTML 로 구조를 작성하기 위해서, <a href="https://github.com/JohnSundell/Plot"><code>Plot</code></a>이라는 JohnSundell이 만든 라이브러리를 사용합니다.</p><p>기존에는</p><pre><code><span class="keyword">let</span> html = <span class="type">HTML</span>(
    .<span class="call">head</span>(
        .<span class="call">title</span>(<span class="string">"My website"</span>),
        .<span class="call">stylesheet</span>(<span class="string">"styles.css"</span>)
    ),
    .<span class="call">body</span>(
        .<span class="call">div</span>(
            .<span class="call">h1</span>(<span class="string">"My website"</span>),
            .<span class="call">p</span>(<span class="string">"Writing HTML in Swift is pretty great!"</span>)
        )
    )
)
</code></pre><p>이런 방식으로 작성했지만, Plot이 업데이트 되면서, Component 프로토콜을 사용해서 Component 요소들을 SwiftUI와 유사한 방식으로 작성할 수 있습니다.</p><pre><code><span class="keyword">struct</span> NewsArticle: <span class="type">Component</span> {
    <span class="keyword">var</span> imagePath: <span class="type">String</span>
    <span class="keyword">var</span> title: <span class="type">String</span>
    <span class="keyword">var</span> description: <span class="type">String</span>

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Article</span> {
            <span class="type">Image</span>(url: imagePath, description: <span class="string">"Header image"</span>)
            <span class="type">H1</span>(title)
            <span class="type">Span</span>(description).<span class="call">class</span>(<span class="string">"description"</span>)
        }
        .<span class="call">class</span>(<span class="string">"news"</span>)
    }
}
</code></pre><p>이런 방식으로 말이죠</p><p>간단하게 알아 봤으니 한번 Publish에서 사용해보겠습니다. 먼저 가장 먼저 보일 부분인 Index 부분을 커스텀해보겠습니다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    &lt;#code#&gt;
}
</code></pre><p>먼저 <code>HTML</code>이라는 구조체를 <code>makeIndexHTML</code> 메서드에 추가해줍니다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="comment">/// HTML 구조체 내에 node를 추가할 수 있는 형태</span>
    <span class="type">HTML</span>()

    <span class="comment">/// HTML 구조체에 들어갈 head 부분이랑 body 부분을 init에서 분리해주는 형태</span>
    <span class="type">HTML</span>(head: [], body: {})
}
</code></pre><p>위 두가지 HTML 에서 하나를 선택해주시면 됩니다. 저는 위 방식으로 진행하도록 하겠습니다.</p><p>먼저 사용할 언어를 선택해줍니다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>) <span class="comment">/// &lt;html lang="$(main에서 설정한 언어)"&gt;</span>
    )
}
</code></pre><p>Head에 필요한 정보들을 넣어줍니다. 저는 publish에서 제공해주는 head static 메서드를 통해서 구성해주도록 하겠습니다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>)
    )
}
</code></pre><p>빌드를 돌리게 되면</p><img width=80% src="https://github.com/jihoonahn/blog/assets/68891494/af1b26e6-2045-4775-bcae-877912ca7b84"></img><p>이런식으로 Head 부분이 쉽게 구축이 된것을 확인 할 수 있습니다. publish에서 제공하는 head 메서드는 저희가 따로 node로 넣어줄 필요없이 가장 자주 사용되는것들로 구성해 줍니다.</p><p>하지만 웹에서는 /style.css에러가 발생합니다. 이 부분은</p><pre><code><span class="keyword">static func</span> head&lt;T: <span class="type">Website</span>&gt;(
    for location: <span class="type">Location</span>,
    on site: <span class="type">T</span>,
    titleSeparator: <span class="type">String</span> = <span class="string">" | "</span>,
    stylesheetPaths: [<span class="type">Path</span>] = [<span class="string">"/styles.css"</span>],
    rssFeedPath: <span class="type">Path</span>? = .<span class="dotAccess">defaultForRSSFeed</span>,
    rssFeedTitle: <span class="type">String</span>? = <span class="keyword">nil</span>
) -&gt; <span class="type">Node</span> {}
</code></pre><p>head static 메서드가 선언된 부분을 보면 알 수 있습니다. <br/></p><p><code>stylesheetPath</code>에 내용이 들어가지 않기 때문에, 자동으로 style.css 부분을 넣어줘서, 현재는 style.css 파일이 없기 때문에 에러가 발생하는 것입니다.</p><pre><code>.<span class="call">head</span>(for: index, on: context.<span class="property">site</span>, stylesheetPaths: [])
</code></pre><p>그래서 아직 stylesheet 넣지 않을것이라면 이런식으로 빈 배열로 값을 넣어주면 에러가 발생하지 않습니다.</p><p>그 다음은 Body 입니다. <br/> Body 같은 경우도 node로 추가하는 방법도 있지만, 앞에서 말했던 Component를 사용해봅시다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>),
        .<span class="call">body</span> { 
            <span class="comment">// Body Code</span>
        }
    )
}
</code></pre><h2>Component 사용법</h2><p>Component를 사용하기 위해서는 <code>Component</code> 라는 프로토콜을 상속 받아줍니다.</p><pre><code><span class="keyword">struct</span> ComponentName: <span class="type">Component</span> 
</code></pre><p>이렇게 상속을 받아주면</p><pre><code><span class="keyword">struct</span> ComponentName: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {}
}
</code></pre><p>이런식으로 SwiftUI와 비슷한 스타일로 Component body 부분에서 기존에 사용하던 <code>Node</code> 또는 다른 <code>Component</code>를 이곳에 넣을 수 있습니다.</p><pre><code><span class="keyword">struct</span> ComponentName: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Div</span> {
            ...
        }
        .<span class="call">class</span>(<span class="string">"site-div"</span>)
    }
}
</code></pre><p>이런식으로 Component를 제작할 수 있습니다.</p><p>현재 Plot에서 제공하고 있는 Component에서 사용할 수 있는 <a href="https://github.com/JohnSundell/Plot/blob/master/Sources/Plot/API/HTMLComponents.swift"><code>HTMLComponent</code></a> 입니다.</p><pre><code><span class="comment">/// A container component that's rendered using the `&lt;article&gt;` element.</span>
<span class="keyword">public typealias</span> Article = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Article</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;aside&gt;` element.</span>
<span class="keyword">public typealias</span> Aside = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Aside</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;button&gt;` element.</span>
<span class="keyword">public typealias</span> Button = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Button</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;div&gt;` element.</span>
<span class="keyword">public typealias</span> Details = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Details</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;div&gt;` element.</span>
<span class="keyword">public typealias</span> Div = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Div</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;fieldset&gt;` element.</span>
<span class="keyword">public typealias</span> FieldSet = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">FieldSet</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;footer&gt;` element.</span>
<span class="keyword">public typealias</span> Footer = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Footer</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h1&gt;` element.</span>
<span class="keyword">public typealias</span> H1 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H1</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h2&gt;` element.</span>
<span class="keyword">public typealias</span> H2 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H2</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h3&gt;` element.</span>
<span class="keyword">public typealias</span> H3 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H3</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h4&gt;` element.</span>
<span class="keyword">public typealias</span> H4 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H4</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h5&gt;` element.</span>
<span class="keyword">public typealias</span> H5 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H5</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;h6&gt;` element.</span>
<span class="keyword">public typealias</span> H6 = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">H6</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;header&gt;` element.</span>
<span class="keyword">public typealias</span> Header = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Header</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;li&gt;` element.</span>
<span class="keyword">public typealias</span> ListItem = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">ListItem</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;main&gt;` element.</span>
<span class="keyword">public typealias</span> Main = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Main</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;nav&gt;` element.</span>
<span class="keyword">public typealias</span> Navigation = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Navigation</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;p&gt;` element.</span>
<span class="keyword">public typealias</span> Paragraph = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Paragraph</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;span&gt;` element.</span>
<span class="keyword">public typealias</span> Span = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Span</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;summary&gt;` element.</span>
<span class="keyword">public typealias</span> Summary = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Summary</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;caption&gt;` element.</span>
<span class="keyword">public typealias</span> TableCaption = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">TableCaption</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;td&gt;` element.</span>
<span class="keyword">public typealias</span> TableCell = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">TableCell</span>&gt;
<span class="comment">/// A container component that's rendered using the `&lt;th&gt;` element.</span>
<span class="keyword">public typealias</span> TableHeaderCell = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">TableHeaderCell</span>&gt;
</code></pre><p>이부분을 통해서 Component를 제작하실때 필요한 HTML Element를 사용할 수 있습니다.</p><p>Component가 잘 제작이 됬다면</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>),
        .<span class="call">body</span> { 
            <span class="type">HeaderComponent</span>() <span class="comment">// 제작한 Component</span>
            <span class="type">PostsLayout</span>()     <span class="comment">// 제작한 Component</span>
            <span class="type">FooterComponent</span>() <span class="comment">// 제작한 Component</span>
        }
    )
}
</code></pre><p>이런식으로 body에 넣어서 추가가 가능하죠. 간단하게 Component를 추가하는 방법에 대해서 알아보았습니다.</p><p>그럼 한번 제대로된 Publish 프로젝트 하나를 만들어보면서 어떻게 사용해야하는지 감을 잡아봅시다.</p><h2>Example</h2><p>간단하게 디자인 한 이미지를 토대로 개발해보도록 하겠습니다.</p><img width = 100% src = "https://github.com/jihoonahn/blog/assets/68891494/6155676b-0bc2-4661-825d-ad521f4b5df1"></img><p>먼저 기존에 만들어둔 Example에서 진행을 해보겠습니다.</p><pre><code>- <span class="type">Components</span>
- <span class="type">Layouts</span>
- <span class="type">Pages</span>
- <span class="type">Utils</span>
</code></pre><p>Website를 만들때 이렇게 3가지로 폴더를 분리하였습니다.</p><ul><li><code>Components</code>: <code>Components</code>는 <code>Header</code> 와 <code>Footer</code> 같은 페이지에 필요한 컴포넌트의 집합</li><li><code>Layouts</code>: <code>Layouts</code> 은 page template와 같은 재사용 가능한 UI 구조를 제공합니다.</li><li><code>Pages</code>: <code>Pages</code>는 웹사이트의 모든 페이지에 대한 레이아웃을 처리합니다.</li><li><code>Utils</code>: 코드에 추가적으로 필요한 작업이나 확장 관련된 내용이 포함이 됩니다.</li></ul><p>예시 프로젝트의 폴더에 대한 정보를 봤으니</p><p>일단 모든 페이지에서 공통적으로 사용되는 <code>Header</code>와 <code>Footer</code>부터 작업해보도록 하겠습니다.</p><p>먼저 Header입니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/06bb2285-673e-48d7-a0b3-40270bcdabf3"></img><p>Header부분을 보면 이런식으로 구성되어 있습니다. <br/> Logo를 눌렀을때 index 페이지로 이동하게 하고, section을 눌렀을 때 각각 section에 맞는 페이지로 이동을하는 기능이 필요합니다.</p><pre><code><span class="keyword">struct</span> HeaderComponent: <span class="type">Component</span>
</code></pre><p>먼저 Components 부분에서 HeaderComponent라는 것을 추가하고 Component 프로토콜을 상속 받게 되면</p><pre><code><span class="keyword">import</span> Publish
<span class="keyword">import</span> Plot

<span class="keyword">struct</span> HeaderComponent: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {}
}
</code></pre><p>이런식으로 body가 자동으로 만들어지고 저희는 site에 어떤 Section이 있고 사용자가 클릭한 section에 대한 정보를 가져와야 하기 때문에</p><pre><code><span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
</code></pre><p><code>Publish</code> 에 있는 PublishingContext를 통해서 정보를 가져올 수 있게 합니다.</p><pre><code><span class="keyword">struct</span> HeaderComponent: <span class="type">Component</span> {
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Header</span> {
            <span class="type">Link</span>(<span class="string">"Blog"</span>, url: <span class="string">"/"</span>)
                .<span class="call">class</span>(<span class="string">"header-logo"</span>)
            <span class="type">Div</span> {
                <span class="type">Navigation</span> {
                    <span class="type">List</span>(<span class="type">Example</span>.<span class="type">SectionID</span>.<span class="property">allCases</span>) { sectionID <span class="keyword">in</span>
                        <span class="type">Link</span>(
                            context.<span class="property">sections</span>[sectionID].title,
                            url: context.<span class="property">sections</span>[sectionID].path.<span class="property">absoluteString</span>
                        )
                        .<span class="call">class</span>(<span class="string">"header-nav-menu-link"</span>)
                    }
                }
                .<span class="call">class</span>(<span class="string">"header-nav"</span>)
            }
            .<span class="call">class</span>(<span class="string">"content"</span>)
        }
        .<span class="call">class</span>(<span class="string">"site-header"</span>)
    }
}
</code></pre><p><code>Link</code> 같은 경우는 Html에서 <code>&lt;a&gt;</code> 태그를 담당합니다. Blog 라는 Text를 누르면 기존 타 사이트와 마찬가지로 index 페이지로 이동하도록 만들었고</p><p><code>Section</code> 부분은 List를 사용해서 저희가 <code>main.swift</code> 에 등록한 Section들을 모두 보여주게 만들었습니다.</p><p>그리고 기존 디자인에 맞춰서 코드를 넣어주고 <code>styles.css</code> 에서 style 관련 css 코드를 넣어주었습니다.</p><p>그렇게 하면 이렇게 디자인 했던 것처럼 결과 값을 받아보실 수 있습니다.</p><img src="https://github.com/jihoonahn/blog/assets/68891494/945b5880-100d-4439-ae26-b57c87cea2da"></img><p>그 다음은 Footer 입니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/20cb53bc-5a73-4155-a171-39d6bd79711d"></img><p>굉장하게 간단한 Footer 입니다.</p><p>Text로 구성하고 싶고, <code>Copyright Link</code> 부분을 누르면 저의 깃허브로 이동하도록 만들고 싶네요.</p><pre><code><span class="keyword">struct</span> FooterComponent: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Footer</span> {
            <span class="comment">// code</span>
        }
        .<span class="call">class</span>(<span class="string">"site-footer"</span>)
    }
}
</code></pre><p>Component를 선언후에 Footer를 넣어주고</p><pre><code><span class="keyword">struct</span> FooterComponent: <span class="type">Component</span> {
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Footer</span> {
            <span class="type">Paragraph</span>(<span class="string">"Made with Publish"</span>)
            <span class="type">Paragraph</span> {
                <span class="type">Text</span>(<span class="string">"Copyright © "</span>)
                <span class="type">Link</span>(<span class="string">"Jihoonahn"</span>, url: <span class="string">"https://github.com/jihoonahn"</span>)
            }
            .<span class="call">class</span>(<span class="string">"copyright"</span>)
        }
        .<span class="call">class</span>(<span class="string">"site-footer"</span>)
    }
}
</code></pre><p>이렇게 간단하게 구축했습니다.</p><p><code>Paragraph</code> 가 HTML에서는 <code>&lt;p&gt;</code> 태그의 역할을 하고, 저희는 copyright 부분중에 Jihoonahn 이라고 적힌 부분을 눌렀을 때 깃허브로 이동시키고 싶으니 이렇게 <code>Paragraph</code> 내부에 <code>Text</code> 와 <code>Link</code> 를 넣어줍니다.</p><p>이렇게 되면 <code>"Copyright © "</code> 부분을 눌렀을 때는 링크로 이동하지 않지만, <code>Jihoonahn</code> 을 눌렀을때만 이동을 하게 됩니다.</p><p>마찬가지로 기존 디자인에 맞춰서 코드를 넣어주고 <code>styles.css</code> 에서 style 관련 css 코드를 넣어주었습니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/a7fd064d-7048-4151-9acf-7712b2474bbf"></img><p>간단하게 Header 와 Footer Component를 만들었고 한번 이제 페이지를 구축해볼까요?</p><h3>Index</h3><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>, stylesheetPaths: []),
        .<span class="call">body</span> {
            <span class="comment">// Index Page</span>
        }
    )
}
</code></pre><p>기존의 <code>HTMLFactory</code> 에서 index부분 부터 한번 작업을 해보도록하겠습니다.</p><p>Index의 Page부분을 만들기 위해서 <code>Pages</code> 폴더에서 <code>IndexPage.swift</code> 파일을 만들었습니다.</p><pre><code><span class="keyword">struct</span> IndexPage: <span class="type">Component</span> {
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>여러개의 Component가 동시에 들어가기 때문에 <code>ComponentGroup</code> 로 묶어 두고 기존에 만들어둔 Header와 Footer을 넣어둡니다.</p><p>그리고 <code>Layouts</code> 폴더에 <code>PostsLayout.swift</code> 란 파일을 만들어서</p><pre><code><span class="keyword">struct</span> PostsLayout: <span class="type">Component</span>
</code></pre><p><code>PostsLayout</code> 이라는 Component를 만들고</p><p>다시 IndexPage로 돌아가서</p><pre><code><span class="keyword">struct</span> IndexPage: <span class="type">Component</span> {
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">PostsLayout</span>()
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>이런식으로 <code>PostsLayout</code> 도 추가로 넣어둡니다.</p><p>그리고 <code>IndexPage</code> 를 <code>HTMLFactory</code> 의 <code>makeIndexHTML</code> method에 넣어줍니다.</p><pre><code><span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Index</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: index, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">IndexPage</span>(context: context)
        }
    )
}
</code></pre><p>그럼 이제 Index 부분을 완성하기 위해서 <code>PostsLayout</code> 부분을 채워볼까요?</p><p>Posts 같은 경우</p><img src="https://github.com/jihoonahn/blog/assets/68891494/30bdd5a9-8e18-4ffd-9817-b7a2af4ed663"></img><p>이 부분이 반복됩니다. 전체가 링크로 감싸져 있는 형태이죠.</p><p>시작하기 전에 Publish에서 확장이 되어 있지 않는 Component가 몇가지 있습니다. 그중에 PostsLayout에서 사용하고 싶은 <code>section</code> 도 아직은 존재하지 않죠</p><p>그러므로 만약 없는 Component들은 어떻게 해야하는지 보도록 하겠습니다.</p><p><code>Utils/Plot/ElementDefinitions.swift</code> 파일을 보시면 됩니다.</p><p><code>Publish</code> 의 HTML 부분을 담당하는 <code>Plot</code> 에서 <code>Section</code> 이 <code>Node</code>에서는 <code>Component</code> 타입으로 존재하지 않는것이기 때문에</p><pre><code><span class="keyword">extension</span> <span class="type">ElementDefinitions</span> {
    <span class="keyword">enum</span> Section: <span class="type">ElementDefinition</span> { <span class="keyword">public static var</span> wrapper = <span class="type">Node</span>.<span class="property">section</span> }
}

<span class="keyword">typealias</span> Section = <span class="type">ElementComponent</span>&lt;<span class="type">ElementDefinitions</span>.<span class="type">Section</span>&gt;
</code></pre><p>이런 방식으로 기존의 Plot의 <code>ElementDefinitions</code> 부분을 참고하여 확장하시면 됩니다.</p><p>이제 <code>PostsLayout</code> 을 제작해보겠습니다.</p><pre><code><span class="keyword">let</span> items: [<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;]
</code></pre><ul><li><code>items</code> 는 Post들을 가져오는 역할을 합니다.</li></ul><p>이 프로퍼티를 추가해주고 <code>IndexPage.swift</code> 를 수정해줍니다.</p><pre><code><span class="keyword">struct</span> IndexPage: <span class="type">Component</span> {
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">PostsLayout</span>(items: context.<span class="call">allItems</span>(sortedBy: \.<span class="property">date</span>))
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>이런 식으로 Context의 모든 Item을 들고오면서 날짜 순서대로 정렬이 되도록 해뒀습니다.</p><p>다시 <code>PostsLayout</code> 부분으로 돌아가서</p><pre><code><span class="keyword">struct</span> PostsLayout: <span class="type">Component</span> {
    <span class="keyword">let</span> items: [<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;]
    
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Section</span> {
            <span class="type">Div</span> {
                <span class="type">List</span>(items) { item <span class="keyword">in</span>
                    <span class="type">Article</span> {
                        <span class="type">Link</span>(url: item.<span class="property">path</span>.<span class="property">absoluteString</span>) {
                            <span class="type">Paragraph</span>(item.<span class="property">tags</span>.<span class="property">map</span>{ $0.<span class="property">string</span> }.<span class="call">joined</span>(separator: <span class="string">", "</span>))
                                .<span class="call">class</span>(<span class="string">"posts-tag"</span>)
                            <span class="type">H3</span>(item.<span class="property">title</span>)
                                .<span class="call">class</span>(<span class="string">"posts-title"</span>)
                            <span class="type">Paragraph</span>(item.<span class="property">description</span>)
                                .<span class="call">class</span>(<span class="string">"posts-description"</span>)
                        }
                        .<span class="call">class</span>(<span class="string">"posts-link"</span>)
                    }
                    .<span class="call">class</span>(<span class="string">"posts-article"</span>)
                }
                .<span class="call">class</span>(<span class="string">"posts-list"</span>)
            }
            .<span class="call">class</span>(<span class="string">"site-posts-inner"</span>)
        }
        .<span class="call">class</span>(<span class="string">"site-posts"</span>)
    }
}
</code></pre><p><code>items</code> 값을 <code>List(&lt;ul&gt;)</code>로 보여줄 수 있도록 제작하고 <code>styles.css</code> 에 css 코드를 넣어주면 됩니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/8db4b824-1c1e-48a0-a5f2-66e761a9ccf0"></img><p>실행을 해보면 위 Index 디자인한것과 같은 결과물을 얻을 수 있습니다.</p><p>그 다음으로는 Section 부분을 처리해보겠습니다.</p><h3>Section</h3><pre><code><span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: section, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="comment">// Section Code</span>
        }
    )
}
</code></pre><p><code>HTMLFactory</code> 부분에서 <code>makeSectionHTML</code> 메서드에 Section 코드를 추가하면 됩니다.</p><pre><code><span class="keyword">struct</span> SectionPage: <span class="type">Component</span>
</code></pre><p><code>Pages/Section/SectionPage.swift</code> 파일에 SectionPage라는 Component를 만들고</p><pre><code><span class="keyword">var</span> section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;
<span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
</code></pre><p>Example의 <code>section</code> 과 <code>Context</code> 를 가져와 줍니다.</p><pre><code><span class="keyword">struct</span> SectionPage: <span class="type">Component</span> {
    <span class="keyword">var</span> section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="keyword">switch</span> section.<span class="property">path</span>.<span class="property">string</span> {
        <span class="keyword">case</span> <span class="type">Example</span>.<span class="type">SectionID</span>.<span class="property">blog</span>.<span class="property">rawValue</span>:
            <span class="keyword">return</span> <span class="type">IndexPage</span>(context: context)
        <span class="keyword">case</span> <span class="type">Example</span>.<span class="type">SectionID</span>.<span class="property">about</span>.<span class="property">rawValue</span>:
            <span class="comment">// About Page</span>
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="type">Div</span>()
        }
    }
}
</code></pre><p>이렇게 section의 path가 <code>blog</code>이면 <code>IndexPage</code>를 보여주게 하고 <code>about</code> 이라면 <code>AboutPage</code>를 보여주게 만듭니다.</p><pre><code><span class="keyword">struct</span> AboutPage: <span class="type">Component</span> {
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
    
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">Div</span> {
                <span class="type">Image</span>(<span class="string">"/images/AboutPageImage.svg"</span>)
                <span class="type">H2</span>(<span class="string">"Publish Example"</span>)
                <span class="type">Paragraph</span>(<span class="string">"Jihoonahn’s Blog Example"</span>)
            }
            .<span class="call">class</span>(<span class="string">"site-about"</span>)
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>그리고 <code>SectionPage</code>에 넣어둘 <code>AboutPage</code>가 필요하기 때문에 간단하게 제작하고,</p><pre><code><span class="keyword">struct</span> SectionPage: <span class="type">Component</span> {
    <span class="keyword">var</span> section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="keyword">switch</span> section.<span class="property">path</span>.<span class="property">string</span> {
        <span class="keyword">case</span> <span class="type">Example</span>.<span class="type">SectionID</span>.<span class="property">blog</span>.<span class="property">rawValue</span>:
            <span class="keyword">return</span> <span class="type">IndexPage</span>(context: context)
        <span class="keyword">case</span> <span class="type">Example</span>.<span class="type">SectionID</span>.<span class="property">about</span>.<span class="property">rawValue</span>:
            <span class="keyword">return</span> <span class="type">AboutPage</span>(context: context)
        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="type">Div</span>()
        }
    }
}
</code></pre><p>이렇게 넣어두면</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/04a19586-afba-485e-8304-10071c65af01"></img><p>이렇게 Header에 있는 <code>About</code> Section을 누르게 되면 <code>AboutPage</code> 로 이동이 되게 만들 수 있습니다.</p><h3>Post</h3><p>그 다음으로는 Index에서 Post중 하나를 눌렀을 때 그 Post의 내용을 볼 수 있도록 만들겠습니다.</p><pre><code><span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: item, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="comment">/// Post</span>
        }
    )
}
</code></pre><p>이곳에 <code>post</code> 들의 item을 가져올 수 있습니다.</p><pre><code><span class="keyword">struct</span> PostLayout: <span class="type">Component</span>
</code></pre><p><code>Layouts/PostLayout.swift</code> 에서 위 Index와 비슷하게 <code>PostLayout</code> 이라는 Component를 만들어주겠습니다.</p><p>그리고 <code>PostLayout</code> 부분에서 Item 내용을 가져오기 위해서</p><pre><code><span class="keyword">var</span> item: <span class="type">Item</span>&lt;<span class="type">Example</span>&gt;
<span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
</code></pre><ul><li><code>item</code> 프로퍼티를 통해서 가져올 수 있도록 하였습니다.</li><li><code>context</code>는 tag의 url을 가져오기 위해서 사용하였습니다.</li></ul><pre><code><span class="keyword">struct</span> PostLayout: <span class="type">Component</span> {
    <span class="keyword">var</span> item: <span class="type">Item</span>&lt;<span class="type">Example</span>&gt;
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">Section</span> {
            <span class="type">Article</span> {
                <span class="type">Div</span> {
                    <span class="keyword">for</span> tag <span class="keyword">in</span> item.<span class="property">tags</span> {
                        <span class="type">Link</span>(tag.<span class="property">string</span>, url: context.<span class="property">site</span>.<span class="call">url</span>(for: tag))
                            .<span class="call">class</span>(<span class="string">"post-tag"</span>)
                    }
                    <span class="type">H2</span>(item.<span class="property">title</span>)
                        .<span class="call">class</span>(<span class="string">"post-title"</span>)
                    <span class="type">Paragraph</span>(<span class="type">DateFormatter</span>.<span class="property">time</span>.<span class="call">string</span>(from: item.<span class="property">date</span>))
                        .<span class="call">class</span>(<span class="string">"post-date"</span>)
                }
                .<span class="call">class</span>(<span class="string">"site-post-header"</span>)
                <span class="type">Div</span> {
                    <span class="type">Div</span> {
                        <span class="type">Node</span>.<span class="call">contentBody</span>(item.<span class="property">body</span>)
                    }
                }
                .<span class="call">class</span>(<span class="string">"site-post-content"</span>)
            }
            .<span class="call">class</span>(<span class="string">"site-post-article"</span>)
        }
        .<span class="call">class</span>(<span class="string">"site-post"</span>)
    }
}
</code></pre><p>디자인 대로 구축한 <code>PostLayout</code> 코드입니다.</p><pre><code><span class="keyword">for</span> tag <span class="keyword">in</span> item.<span class="property">tags</span> {
    <span class="type">Link</span>(tag.<span class="property">string</span>, url: context.<span class="property">site</span>.<span class="call">url</span>(for: tag))
        .<span class="call">class</span>(<span class="string">"post-tag"</span>)
}
</code></pre><p>item에 있는 tag들을 가져와서 눌렀을때 Tag에 관련된 Post를 찾을 수 있는 페이지로 이동시킵니다.</p><pre><code><span class="type">Node</span>.<span class="call">contentBody</span>(item.<span class="property">body</span>)
</code></pre><p>그리고 저희가 <code>Content</code> 파일에 markdown으로 추가한 내용을 볼 수 있도록 <code>Node</code> 의 <code>contentBody</code> 메서드를 사용해주시면 됩니다.</p><pre><code><span class="keyword">struct</span> PostPage: <span class="type">Component</span> {
    <span class="keyword">var</span> item: <span class="type">Item</span>&lt;<span class="type">Example</span>&gt;
    <span class="keyword">var</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">PostLayout</span>(item: item, context: context)
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>그리고 <code>PostLayout</code>을 만들었으니, <code>PostPage</code> 에 <code>PostLayout</code>을 가져와주시면 됩니다.</p><pre><code><span class="keyword">func</span> makeItemHTML(for item: <span class="type">Item</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: item, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">PostPage</span>(item: item, context: context)
        }
    )
}
</code></pre><p>다시 <code>HTMLFactory</code> 부분으로 돌아가서 <code>PostPage</code> 부분을 body에 넣어주시면</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/1043641c-3e1e-4bec-bc31-6612f6a0bfdf"></img><p>이렇게 Markdown에 있는 Post가 잘 작동하는 것을 확인할 수 있습니다.</p><h3>Page</h3><p><code>makePageHTML</code> 부분은 특별하게 예시에서는 사용하고 있지 않기 때문에</p><pre><code><span class="keyword">func</span> makePageHTML(for page: <span class="type">Page</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span> {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            page.<span class="property">body</span>
        }
    )
}
</code></pre><p><code>page.body</code> 만 보이게 해뒀습니다.</p><h3>Tag List</h3><p>그 다음은 <code>TagList</code> 입니다. Post에 있는 모든 Tag들을 한번에 가져와서 볼 수 있게 하는 역할을 합니다.</p><pre><code><span class="keyword">func</span> makeTagListHTML(for page: <span class="type">Publish</span>.<span class="type">TagListPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="comment">// TagList Code</span>                
        }
    )
}
</code></pre><p><code>HTMLFactory</code> 부분에서 <code>makeTagListHTML</code> 에서 처리할 수 있습니다.</p><pre><code><span class="keyword">struct</span> TagListPage: <span class="type">Component</span>
</code></pre><p>먼저 <code>TagListPage</code> 에서 마찬가지로 Component를 생성하고</p><pre><code><span class="keyword">let</span> tags: <span class="type">Set</span>&lt;<span class="type">Tag</span>&gt;
</code></pre><p><code>TagListPage</code>에서는 <code>Publish.TagListPage</code>에 있는 모든 태그를 들고 올 수 있게 <code>Set&lt;Tag&gt;</code> 타입을 사용합니다.</p><pre><code><span class="keyword">struct</span> TagListPage: <span class="type">Component</span> {
    <span class="keyword">let</span> tags: [<span class="type">Tag</span>]
    <span class="keyword">let</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
    
    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">List</span>(tags) { tag <span class="keyword">in</span>
                <span class="type">ListItem</span> {
                    <span class="type">Link</span>(tag.<span class="property">string</span>, url: context.<span class="property">site</span>.<span class="call">url</span>(for: tag))
                }
                .<span class="call">class</span>(<span class="string">"site-tag"</span>)
            }
            .<span class="call">class</span>(<span class="string">"site-tagList"</span>)
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>그리고 <code>tags</code> 를 List에 넣어서 보여주고 <code>styles.css</code> 에서 간단한 css 코드만 추가해주었습니다.</p><pre><code><span class="keyword">func</span> makeTagListHTML(for page: <span class="type">Publish</span>.<span class="type">TagListPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">TagListPage</span>(tags: page.<span class="property">tags</span>, context: context)
        }
    )
}
</code></pre><p>다시 <code>HTMLFactory</code> 코드로 돌아와서 <code>TagListPage</code>를 넣어줍니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/f069ee2d-da19-4d8a-a44e-9e1dd386174b"></img><p>이렇게 디자인과 같은 TagList 페이지를 얻을 수 있습니다.</p><h3>TagDetail</h3><p>마지막 <code>TagDetail</code> 부분입니다. 지정된 tag를 눌렀을 때 이 tag를 가지고 있는 post를 보여주는 역할을 합니다.</p><pre><code><span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">Publish</span>.<span class="type">TagDetailsPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="comment">// Tag Details Code</span>
        }
    )
}
</code></pre><p><code>HTMLFactory</code>에서 마지막 하나 남은 메서드인 <code>makeTagDetailsHTML</code> 에서 작업을 하실 수 있습니다.</p><pre><code><span class="keyword">struct</span> TagDetailPage: <span class="type">Component</span>
</code></pre><p><code>TagDetailPage</code>라는 Component를 선언하고</p><pre><code><span class="keyword">let</span> items: [<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;]
<span class="keyword">let</span> selectedTag: <span class="type">Tag</span>
</code></pre><ul><li><code>items</code>: Tag에 포함된 post들을 가져옵니다.</li><li><code>selectedTag</code>: 선택된 Tag의 정보를 알려줍니다.</li></ul><p>위의 프로퍼티들을 추가해주시고</p><pre><code><span class="keyword">struct</span> TagDetailsPage: <span class="type">Component</span> {
    <span class="keyword">let</span> items: [<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;]
    <span class="keyword">let</span> context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;
    <span class="keyword">let</span> selectedTag: <span class="type">Tag</span>

    <span class="keyword">var</span> body: <span class="type">Component</span> {
        <span class="type">ComponentGroup</span> {
            <span class="type">HeaderComponent</span>(context: context)
            <span class="type">Div</span> {
                <span class="type">H2</span>(selectedTag.<span class="property">string</span>)
                <span class="type">PostsLayout</span>(items: items)
            }
            .<span class="call">class</span>(<span class="string">"site-tagDetails"</span>)
            <span class="type">FooterComponent</span>()
        }
    }
}
</code></pre><p>기존의 <code>PostsLayout</code> 을 가져오는 방식으로 간단하게 처리하고</p><pre><code><span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">Publish</span>.<span class="type">TagDetailsPage</span>, context: <span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">HTML</span>? {
    <span class="type">HTML</span>(
        .<span class="call">lang</span>(context.<span class="property">site</span>.<span class="property">language</span>),
        .<span class="call">head</span>(for: page, on: context.<span class="property">site</span>),
        .<span class="call">body</span> {
            <span class="type">TagDetailsPage</span>(
                items: context.<span class="call">items</span>(
                    taggedWith: page.<span class="property">tag</span>,
                    sortedBy: \.<span class="property">date</span>
                ),
                context: context,
                selectedTag: page.<span class="property">tag</span>
            )
        }
    )
}
</code></pre><p>이렇게 <code>HTMLFactory</code>의 <code>makeTagDetailsHTML</code>에 넣어주시면 되는데,</p><pre><code>items: context.<span class="call">items</span>(
    taggedWith: page.<span class="property">tag</span>,
    sortedBy: \.<span class="property">date</span>
),
</code></pre><p><code>items</code>를 가져오는 부분을 보면 context의 items를 가져오는데 <code>page.tag</code>가 포함되어 있는 <code>item</code> 만 가져오게 해준다라고 생각하시면 될것 같습니다.</p><img width=100% src="https://github.com/jihoonahn/blog/assets/68891494/30e5ace0-1f7e-408a-b779-687e48114af1"></img><p>이런식으로 Tag를 눌렀을때 잘 조회가 되는것을 확인할 수 있습니다. 이렇게 해서 저희는 Publish로 웹사이트 하나를 뚝딱 만들어 봤습니다.</p><p>위에서 진행한 내용은 <a href="https://github.com/Jihoonahn/Blog-Document/tree/main/Publish/part2">예시코드</a> 를 확인할 수 있습니다.</p><hr><p>이번 글에서는 Publish에서 HTML을 작성하는 방법과, 직접 예제를 만들어보며 Publish를 이용해서 실질적인 웹사이트를 만들어 봤습니다.</p><p>다음글에서는 Publish로 만든 웹사이트를 배포하는 법에 대해서 작성할 예정입니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/publish-part-1</guid><title>Publish 사용하기 part 1</title><description>Swift publish 구조 살펴보기</description><link>https://blog.jihoon.me/blog/publish-part-1</link><pubDate>Tue, 12 Sep 2023 04:03:00 +0000</pubDate><content:encoded><![CDATA[<h2>Publish 구조 살펴보기</h2><p>기존 처음 Publish 프로젝트를 생성하고, <code>main.swift</code> 코드입니다.</p><pre><code><span class="keyword">import</span> Foundatio
<span class="keyword">import</span> Publish
<span class="keyword">import</span> Plot

<span class="comment">// This type acts as the configuration for your website.</span>
<span class="keyword">struct</span> Example: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="comment">// Add the sections that you want your website to contain here:</span>
        <span class="keyword">case</span> posts
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
        <span class="comment">// Add any site-specific metadata that you want to use here.</span>
    }

    <span class="comment">// Update these properties to configure your website:</span>
    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://your-website-url.com"</span>)!
    <span class="keyword">var</span> name = <span class="string">"Example"</span>
    <span class="keyword">var</span> description = <span class="string">"A description of Part"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
}

<span class="comment">// This will generate your website using the built-in Foundation theme:</span>
<span class="keyword">try</span> <span class="type">Example</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)

</code></pre><p>먼저 위 예시의 Example 구조체 부터 보겠습니다.</p><pre><code><span class="keyword">struct</span> Example: <span class="type">Website</span> {
    <span class="keyword">enum</span> SectionID: <span class="type">String</span>, <span class="type">WebsiteSectionID</span> {
        <span class="comment">// Add the sections that you want your website to contain here:</span>
        <span class="keyword">case</span> posts
    }

    <span class="keyword">struct</span> ItemMetadata: <span class="type">WebsiteItemMetadata</span> {
        <span class="comment">// Add any site-specific metadata that you want to use here.</span>
    }

    <span class="comment">// Update these properties to configure your website:</span>
    <span class="keyword">var</span> url = <span class="type">URL</span>(string: <span class="string">"https://your-website-url.com"</span>)!
    <span class="keyword">var</span> name = <span class="string">"Example"</span>
    <span class="keyword">var</span> description = <span class="string">"A description of Part"</span>
    <span class="keyword">var</span> language: <span class="type">Language</span> { .<span class="dotAccess">english</span> }
    <span class="keyword">var</span> imagePath: <span class="type">Path</span>? { <span class="keyword">nil</span> }
}
</code></pre><ul><li><code>Section ID</code> : 웹사이트의 Section ID를 나타내는 열거형입니다.</li><li><code>itemMetadata</code> : 사용자가 웹사이트에 대한 Meta data 값을 지정할 수 있는 부분입니다.</li><li><code>url</code> : 웹 사이트를 어떤 URL로 호스팅 될지 지정해주는 부분입니다.</li><li><code>name</code> : 웹 사이트의 이름을 지정해주는 부분입니다.</li><li><code>description</code> : 웹사이트에 대한 설명을 지정해주는 부분입니다.</li><li><code>language</code> : 웹사이트에서 사용하는 주요한 언어를 지정해주는 부분입니다.</li><li><code>imagePath</code> : 웹사이트를 나타내는 이미지의 경로를 지정해주는 부분입니다.</li></ul><p>위 예시에는 나와있지 않지만, <code>favicon</code> 과 <code>tagHTMLConfig</code> 값도 있습니다.</p><ul><li><code>favicon</code> : 웹 브라우저의 주소창에 표시되는 아이콘을 설정 할 수 있습니다.</li><li><code>tagHTMLConfig</code> : 웹 사이트에 대한 Tag HTML을 생성할 때 사용이 됩니다.</li></ul><p>Publish에는 기본적으로 <code>Foundation Theme</code> 가 제공됩니다.</p><pre><code><span class="keyword">try</span> <span class="type">Example</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">foundation</span>)
</code></pre><p>이 부분에서 Publish 자체에서 제공하는 <code>Foundation Theme</code> 을 사용한다는 것을 알 수 있습니다.</p><p>커스텀을 시작하기 위해서는 저부분 부터 수정이 필요합니다. <br/><br/></p><h2>테마 커스텀</h2><p>여기서부터 좀 publish 사용 난이도가 많이 올라갑니다.</p><p><code>PublishHTMLFactory.swift</code> 파일을 생성합니다.</p><pre><code><span class="keyword">struct</span> PublishHTMLFactory: <span class="type">HTMLFactory</span>
</code></pre><p>그리고 <code>HTMLFactory</code> protocol을 상속 받으면 구조가 생성이됩니다.</p><p>처음에는 위 예시 코드에서 있던 Example 구조체를 Site typealias에 입력해주면 됩니다.</p><pre><code><span class="keyword">struct</span> PublishHTMLFactory: <span class="type">HTMLFactory</span> {
    <span class="keyword">typealias</span> Site = <span class="type">Example</span>
}
</code></pre><p>이렇게 해주시면,</p><pre><code><span class="keyword">struct</span> PublishHTMLFactory: <span class="type">HTMLFactory</span> {
    <span class="keyword">typealias</span> Site = <span class="type">Example</span>

    <span class="keyword">func</span> makeIndexHTML(for index: <span class="type">Publish</span>.<span class="type">Index</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeSectionHTML(for section: <span class="type">Publish</span>.<span class="type">Section</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeItemHTML(for item: <span class="type">Publish</span>.<span class="type">Item</span>&lt;<span class="type">Example</span>&gt;, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makePageHTML(for page: <span class="type">Publish</span>.<span class="type">Page</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span> {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeTagListHTML(for page: <span class="type">Publish</span>.<span class="type">TagListPage</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span>? {
        &lt;#code#&gt;
    }
    
    <span class="keyword">func</span> makeTagDetailsHTML(for page: <span class="type">Publish</span>.<span class="type">TagDetailsPage</span>, context: <span class="type">Publish</span>.<span class="type">PublishingContext</span>&lt;<span class="type">Example</span>&gt;) <span class="keyword">throws</span> -&gt; <span class="type">Plot</span>.<span class="type">HTML</span>? {
        &lt;#code#&gt;
    }
}
</code></pre><p>이런 코드가 생깁니다.</p><p>각 메서드에 대한 설명을 하겠습니다.</p><ul><li><code>makeIndexHTML</code> : 웹사이트의 main <code>index.html</code> 페이지를 생성합니다.</li><li><code>makeSectionHTML</code> : 웹사이트의 Section 부분에 사용할 <code>index.html</code> 페이지를 생성합니다.</li><li><code>makeItemHTML</code> : 웹사이트의 item에 사용할 HTML 파일을 생성합니다.</li><li><code>makePageHTML</code> : 웹사이트의 page에 사용할 HTML 파일을 생성합니다.</li><li><code>makeTagListHTML</code>: Publish에서 제공하는 Tag 부분의 전체 리스트를 제공해주는 화면입니다.</li><li><code>makeTagDetailsHTML</code> : Tag 부분의 상세 내용을 제공해주는 화면입니다.</li></ul><p><code>HTMLFactory</code>에서 <code>&lt;#code#&gt;</code> 부분 설명이 길어질것 같아서 다음 Post에 작성법에 대해서 상세하게 설명하도록 하겠습니다.</p><p>HTMLFactory 내용을 다 입력하고, Theme를 등록하면 됩니다.</p><pre><code><span class="keyword">import</span> Publish
<span class="keyword">import</span> Plot

<span class="keyword">extension</span> <span class="type">Theme</span> <span class="keyword">where</span> <span class="type">Site</span> == <span class="type">Example</span> {
    <span class="keyword">static var</span> publish: <span class="type">Self</span> {
        <span class="type">Theme</span>(htmlFactory: <span class="type">PublishHTMLFactory</span>())
    }
}
</code></pre><p>이런식으로 Example에서 사용 가능한 <code>publish</code> 테마를 등록하였습니다.</p><pre><code><span class="keyword">try</span> <span class="type">Example</span>().<span class="call">publish</span>(withTheme: .<span class="dotAccess">publish</span>)
</code></pre><p><code>main.swift</code> 파일 부분에서 간단하게는 이렇게 사용이 가능합니다.</p><p>또는 직접 custom pipeline를 구축하는 방법도 있습니다.</p><pre><code><span class="keyword">try</span> <span class="type">Example</span>().<span class="call">publish</span>(using: [
    .<span class="call">optional</span>(.<span class="call">copyResources</span>()),
    .<span class="call">addMarkdownFiles</span>(),
    .<span class="call">generateHTML</span>(withTheme: .<span class="dotAccess">publish</span>),
    .<span class="call">generateRSSFeed</span>(including: [.<span class="dotAccess">posts</span>]),
    .<span class="call">generateSiteMap</span>()
])
</code></pre><p><code>publish(using:)</code> 메서드에서 pipeline을 하나하나 사용자가 원하는대로 지정할 수 있습니다.</p><p>위에서 진행한 내용은 <a href="https://github.com/Jihoonahn/Blog-Document/tree/main/Publish/part1">예시코드</a> 를 확인할 수 있습니다.</p><hr><p>이번 글에서는 Publish 커스텀 중에서 구조를 이루는 부분에 대한 글을 적어봤습니다. <br/> 다음 글에서는 publish에서 HTML을 어떻게 작성하는지에 대한 내용을 작성할 예정입니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/publish-introduce</guid><title>Publish 소개</title><description>Swift로 Static Site 만들기</description><link>https://blog.jihoon.me/blog/publish-introduce</link><pubDate>Tue, 22 Aug 2023 16:51:00 +0000</pubDate><content:encoded><![CDATA[<h2>What is Publish</h2><p><a href="https://github.com/JohnSundell/Publish.git">Publish</a>는 John Sundell님이 만든 정적사이트 생성기 입니다. <br/> Markdown Parser인 Ink와 Swift에서 HTML, XML, RSS를 작성하기 위한 DSL인 Plot을 사용합니다. <br/></p><p>Swift Package로 제공되기 때문에 <code>Package.swift</code> 에 Dependency로 추가하여 사용할 수 있습니다. <br/></p><pre><code><span class="keyword">let</span> package = <span class="type">Package</span>(
    ...
    dependencies: [
        .<span class="call">package</span>(url: <span class="string">"https://github.com/johnsundell/publish.git"</span>, from: <span class="string">"0.9.0"</span>)
    ]
    ...
)
</code></pre><p>Publish에서 제공하는 CLI를 설치할 때 HomeBrew를 지원하며, 깃허브로 따로 설치할 수도 있습니다.</p><pre><code>brew install publish
</code></pre><p>또는 깃허브에서</p><pre><code>$ git clone https://github.<span class="property">com</span>/<span class="type">JohnSundell</span>/<span class="type">Publish</span>.<span class="property">git</span>
$ cd <span class="type">Publish</span>
$ make
</code></pre><p>이렇게 설치하면 됩니다. <br/></p><p>이제 시작할 때</p><pre><code>$ mkdir <span class="type">Example</span>
$ cd <span class="type">Example</span>
$ publish new
</code></pre><p>명령어를 이용하면?</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/1c06f812-0dbc-4fc0-a329-28d807544a55"></img><p>이렇게 파일이 생성이 됩니다.</p><pre><code>$ publish run
</code></pre><p>위 명령어를 통해서 웹사이트를 실행시키면</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/0a9e2214-6c6f-4efc-9b16-6d56acd07051"></img><p>publish에서 제공하는 기본 화면이 보이게 됩니다.</p><p>실행 시키고 나면, Output 폴더가 생기게 됩니다.</p><img width="50%" src="https://github.com/Jihoonahn/Blog/assets/68891494/d4239408-0148-427a-99f7-17cbfd2d87d2"></img><p>그리고 내용 같은 경우는 <code>Content</code> 폴더 안에서 입력이 가능합니다. <br/> 일단 방금 만든 예시로, 첫번째 post 파일을 수정해 보겠습니다.</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/5325cf79-11d9-4983-a14e-74be5fd4e042"></img><p>이렇게 수정하고 다시 빌드 해보면?</p><img width="100%" src="https://github.com/jihoonahn/blog/assets/68891494/707f8bc8-cc8b-4202-8444-3baef852be14"></img><p>이렇게 내용이 잘 적용이 된것을 확인 할 수 있습니다.</p><p>그리고 글 추가 같은 경우는 markdown File 하나만 만들면 됩니다. (간단하죠?)</p><img width="80%" src="https://github.com/Jihoonahn/Blog/assets/68891494/41491c29-dd6f-4755-a781-2da942e1dac0"></img><p>이렇게 글을 추가해 주면 됩니다.</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/eb4533d5-8c5c-48ae-abad-26daba835ec9"></img><p>그러면 추가된 글 까지 보이게 되죠,</p><p>글을 적는 방법을 알아볼까요?</p><pre><code>---
date: <span class="number">2023</span>-<span class="number">08</span>-<span class="number">25 17</span>:<span class="number">09</span>
description: <span class="type">Welcome</span> to publish.
tags: publish, web, static site
---
</code></pre><p>markdown file 위에 정보를 입력해줍니다. <br/> date는 언제 이 글을 작성했는지를 보여주고, description은 글에 대한 짧은 설명을 적습니다. <br/></p><p>그리고 publish 에서는 tag기능을 제공합니다. 저기에 tag를 적어두면?</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/7e5b11ae-798d-45ce-977e-d939f7c1cbde"></img><p>이렇게 <code>https://localhost:8000/tags</code>에 tag들이 추가 되고, tag를 누르면?</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/9d4f0089-04bb-44b9-8052-5449e69d9bb4"></img><p>tag를 가지고 있는 글들을 조회할 수도 있습니다.</p><hr><p>이번 글에서는 간단하게 publish에 대해서 소개하는 글을 적어봤습니다. <br/> 와글와글때 발표했던 내용이랑 중복되는 부분이 많았지만.. 다음 글에서는 publish 커스텀하는 방법, publish로 작성한 글 deploy 하기 등등 publish는 시리즈로 진행할 예정입니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/iga-ios-1</guid><title>제 1회 IGA 발표 회고록</title><description>IGA 발표 회고</description><link>https://blog.jihoon.me/blog/iga-ios-1</link><pubDate>Mon, 10 Jul 2023 13:22:00 +0000</pubDate><content:encoded><![CDATA[<iframe src="https://www.youtube.com/embed/ugNe2yFBRDM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>이번 제 1회 iOS IGA에서 CLI 구축 방법에 대해서 발표를 했고, 이에 대한 회고 입니다. <br/><br/></p><h2>발표 준비</h2><p>발표 전 원래 주제로 <strong>"생산성으로 위한 Script"</strong>에 대해서 발표를 하려고 생각하고 있었습니다. <br/></p><p>하지만 Swift로 작성하는 Script는 하나의 작업을 실행하기 위해서 Script에 많은 양의 코드가 들어가고, 중복되는 코드.. 등등 제작하는 것도 리소스가 많이 소비가 되는데, 하나의 작업을 위해서 제작이 되기 때문에 사람들이 사용할만한 이유가 부족하다고 생각이 되었습니다. <br/></p><p>여러가지 방법을 찾아보다가 Swift Argument Parser라는 라이브러리를 보게 되었고, 오히려 지금 제가 추구하는 생산성은 CLI 쪽이 맞겠다 생각을 해서, 주제를 <strong>"생산성을 위한 CLI 구축"</strong>으로 바꾸게 되었습니다. <br/></p><p>이번 발표에서는 좋은 예제를 만들고 싶어서, 고민을 많이 했습니다.</p><pre><code><span class="number">1</span>. <span class="type">CLI의</span> 장점을 잘 보여주기 위해서 전용 <span class="type">CLI</span> 제작
<span class="number">2</span>. <span class="type">ML이라는</span> 주제를 더 잘 녹여 낼 수 있는 <span class="type">GPT CLI</span> 제작
</code></pre><p>2개의 주제를 가지고 일주일 정도를 고민했습니다. <br/> 1번을 선택하면 발표주제를 더 깊게 설명할 수 있고, 2번을 선택하면 컨퍼런스 주제와 CLI에 대한 흥미를 더 줄 수 있지 않을까? 라고 생각을 했습니다. <br/></p><p>결과적으로는 컨퍼런스 주제를 더 잘 녹여내자는 생각에 2번을 선택했습니다. <br/><br/></p><h2>발표 시작</h2><p>제 발표는 3번째였습니다.</p><img width=100% src = "https://github.com/Jihoonahn/Blog/assets/68891494/e697dfeb-06c2-4a35-9ccb-66fbf2a92c4c"></img><p>처음 추영욱님이 먼저 나가셔서 오프닝을 시작했습니다. 오프닝때 부터 반응이 좋았었고, 오프닝이 끝난 후 저 이전 발표자 분이신 긱코드님이 나가셔서 발표를 진행하셨는데 너무 발표를 재밌게 잘하셔서 더 떨리더라고요 ㅎㅎ.. <br/></p><p>어느정도 떨긴 했지만 최대한 많은 내용을 전달하고자 하는 생각으로 발표를 시작하게 되었습니다.</p><img width=49% src="https://github.com/Jihoonahn/Blog/assets/68891494/a70212a0-c9cb-42f4-8a1e-6674acd71103"></img><img width=49% src="https://github.com/Jihoonahn/Blog/assets/68891494/4bba15b6-63cb-4d70-8f07-45e55f77a40e"></img><p>발표는 다음 순서로 진행이 됬습니다.</p><pre><code><span class="number">1</span>. <span class="type">CLI</span> 제작기
<span class="number">2</span>. <span class="type">CLI</span> vs <span class="type">Script</span>
<span class="number">3</span>. <span class="type">CLI</span> 제작 방법
<span class="number">4</span>. <span class="property">예시</span> 프로젝트
<span class="number">5</span>. <span class="property">저는</span> <span class="type">CLI를</span> 이런 곳에 사용합니다.
<span class="number">6</span>. <span class="type">CLI가</span> 사용되는 곳
</code></pre><p>1번, 2번에서는 목차에서 제가 CLI를 제작하게 된 계기를 위에 Script와 고민했던 것, 그리고 그 이후에 CLI를 제작하게 된 배경에 대해서 설명하고 <br/> 3번째에는 <strong>Swift Argument Parser</strong> 사용 방법에 대해서 이야기 하고, <br/> 4번째에는 위에서 이야기한 CLI에서 GPT를 사용하는 예시 프로젝트에 대해서, <br/> 그리고 5번째는 CLI를 어디서 이용했는지에 대한 이야기를 하였고,<br/> 마지막은 대부분 iOS 개발자들이 알 수 있는 메이저한 라이브러리/프레임워크에서 어디에 사용됬는지에 대해서 이야기 했습니다. <br/><br/></p><h2>느낀점</h2><p>저번에 와글와글 iOS 발표를 하고, 이번에는 처음으로 오프라인 발표를 해봤지만.. 확실히 온라인 발표와 오프라인 발표는 뭐가 쉬웠다 이런게 아닌 두가지 느낌이 완전히 다르다고 느껴졌습니다. <br/></p><p>와글와글때는 온라인에서 발표 전에는 진정이 많이 됬는데, 진행하는 도중에 떨리게 되었고, 이번에 진행한 IGA 오프라인 발표는 발표전에 오히려 많이 떨리고, 진행하면서 진정이 많이되는 느낌을 받았습니다. <br/></p><p>발표를 2번 진행하면서 이번에도 몇번씩 실수를 하는것을 보며, 여전히 부족하다는 것을 깨닳게 되었고, 이번에는 CLI라는 주제가 Swift에서는 자주 발표하는 주제가 아닌 만큼, 걱정이 많이 됬었지만 오거나이저 분들과 스피커 분들도 다들 좋게 말해주셔서 다행이라고 생각이 되었습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/tuist-xcodebeta</guid><title>Xcode-Beta에서 Tuist 사용기</title><description>Xcode Beta에서 tuist edit 명령어에서 에러나는 부분을 해결하는 방법에 대한 포스트입니다.</description><link>https://blog.jihoon.me/blog/tuist-xcodebeta</link><pubDate>Sat, 10 Jun 2023 00:03:00 +0000</pubDate><content:encoded><![CDATA[<h2>Beta를 사용했을때</h2><p>최근에 WWDC23이 공개되었습니다. macOS에서 발표된 내용을 보고 macOS 14와 Xcode 15의 변화에 대해서 보기 위해서, 업데이트를 했습니다.</p><img width="10%" src="https://github.com/jihoonahn/Blog/assets/68891494/9042ff22-337c-459b-b01b-4ab7718c4bcd"></img><p>그렇게 봉인된.. Xcode..</p><p>macOS 14에서는 기존 Xcode 14.3.1(글 작성 기준)를 사용하지 못하게 됩니다. <br/> 그래서 Xcode 15를 설치해야합니다.</p><p><a href="https://xcodereleases.com/">Xcode 설치 링크</a></p><h2>어떤 문제가 있었나..</h2><p>그렇게, Xcode 15를 설치하고 Tuist를 실행 했을 때, 이런 문제가 있더군요. Tuist에서 <code>tuist edit</code> 명령어를 실행했을 때,</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/c22e5b50-273a-45ab-a96e-484d715b014a"></img><p>이런 식으로 실행이 안되는 문제가 있었습니다. <br/> 이유는.. 위에서 빌드업 했지만, 문제는 <a href="https://github.com/tuist/tuist/blob/main/Sources/TuistKit/Services/EditService.swift">Tuist Command Service</a> 부분에 있었습니다. <br/></p><h2>문제는 어디서?</h2><pre><code><span class="keyword">try</span> opener.<span class="call">open</span>(path: workspacePath, application: selectedXcode.<span class="property">path</span>, wait: <span class="keyword">true</span>)
</code></pre><p><a href="https://github.com/tuist/tuist/blob/main/Sources/TuistKit/Services/EditService.swift">tuist &gt; Sources &gt; TuistKit &gt; Services &gt; EditService.swift</a> 의 78번째 줄</p><p>위 코드 부분에서 에러가 발생합니다. <br/></p><p>Xcode 앱을 실행시키는 코드이고, 현재 Xcode는 위 그림처럼 봉인(?)당했기 때문에 Xcode앱을 열 수 없는 것입니다. <br/></p><p>나머지 명령어에서는 문제가 없었지만, <code>tuist edit</code> 명령어에서만 문제가 생기더라고요. <br/> 이 문제에 대한 해결 방법은 없을까요? <br/></p><h2>해결 방법</h2><h3>1. Tuist 명령어만으로 해결하는 방법</h3><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/cd7a8e9c-59c0-435b-9ff2-bb124bb8d9f8"></img><p><code>tuist edit -h</code>를 실행시켜 명령어를 찾아봅시다.</p><p>Tuist 공식 깃허브 코드에서는 permanent가 true면, Xcode앱을 실행시키지 않습니다.</p><pre><code><span class="keyword">let</span> workspacePath = <span class="keyword">try</span> projectEditor.<span class="call">edit</span>(
    at: path,
    in: path,
    onlyCurrentDirectory: onlyCurrentDirectory,
    plugins: plugins
)
logger.<span class="call">notice</span>(<span class="string">"Xcode project generated at</span> \(workspacePath.<span class="property">pathString</span>)<span class="string">"</span>, metadata: .<span class="dotAccess">success</span>)
</code></pre><p>그렇기 떄문에, <code>tuist edit --permanent</code> 명령어를 실행하면?</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/f71302cb-91ad-4e0c-a665-52dde3574409"></img><p>에러가 발생하여 동작이 실패하지 않고, 아래 처럼 프로젝트와 워크스페이스 파일이 생성됩니다.</p><img width="80%" src="https://github.com/Jihoonahn/Blog/assets/68891494/21ac8d5b-9353-4d04-846f-edaa4103fc0d"></img><p>이런식으로 진행이 됬다면, Manifests.xcworkspace 파일을 눌러서, tuist 프로젝트를 수정할 수 있습니다.</p><h3>2. xcode-select의 path를 변경하는 방법</h3><img width="50%" src="https://github.com/Jihoonahn/Blog/assets/68891494/7c9fb32e-6ea6-4154-99c3-fc4c470ad8f2"></img><p>이 방법은 <a href="https://github.com/baekteun">baekteun</a> 이라는 후배가 영감을 준 방법입니다.</p><p>터미널에서</p><pre><code>sudo xcode-select -s /<span class="type">Applications</span>/<span class="type">Xcode</span>-beta.<span class="property">app</span>/<span class="type">Contents</span>/<span class="type">Developer</span>
</code></pre><p>이렇게 xcode-select에서 path를 변경해 줍니다.</p><p>그 이후 다시 <code>tuist edit</code> 명령어를 실행하면 됩니다.</p><img width="100%" src="https://github.com/Jihoonahn/Blog/assets/68891494/ef3d3550-e18a-4d1b-8d76-2e8017574897"></img><p>그렇게 되면 정상적으로 <code>tuist edit</code> 명령어가 작동합니다. <br/><br/></p><h2>후기</h2><p>처음에 <code>tuist edit</code> 명령어가 작동하지 않아서 tuist의 명령어 코드를 보다가 첫번째 방법은 발견하게 되었고, 두번째 방법은 위에서 말했듯 후배에게 영감을 받아서 얻은 방법입니다.</p><p>Tuist에서 <code>Sources/TuistSupport/Xcode/XcodeController.swift</code> 부분을 보게 되면, <code>xcode-select -p</code> 를 통해서 Xcode의 developer 파일 경로를 받아오는 방식입니다.</p><pre><code><span class="comment">/// Returns the selected Xcode. It uses xcode-select to determine
/// the Xcode that is selected in the environment.
///
/// - Returns: Selected Xcode.
/// - Throws: An error if it can't be obtained.</span>
<span class="keyword">public func</span> selected() <span class="keyword">throws</span> -&gt; <span class="type">Xcode</span>? {
    <span class="comment">// Return cached value if available</span>
    <span class="keyword">if let</span> cached = selectedXcode {
        <span class="keyword">return</span> cached
    }

    <span class="comment">// e.g. /Applications/Xcode.app/Contents/Developer</span>
    <span class="keyword">guard let</span> path = <span class="keyword">try</span>? <span class="type">System</span>.<span class="property">shared</span>.<span class="call">capture</span>([<span class="string">"xcode-select"</span>, <span class="string">"-p"</span>]).<span class="call">spm_chomp</span>() <span class="keyword">else</span> {
        <span class="keyword">return nil</span>
    }

    <span class="keyword">let</span> xcode = <span class="keyword">try</span> <span class="type">Xcode</span>.<span class="call">read</span>(path: <span class="keyword">try</span> <span class="type">AbsolutePath</span>(validating: path).<span class="property">parentDirectory</span>.<span class="property">parentDirectory</span>)
    selectedXcode = xcode
    <span class="keyword">return</span> xcode
}
</code></pre><p>근데 처음에 시도할때는 <code>xcode-select</code> 명령어의 option에서 path를 따로 바꿀 수 있다는 사실을 망각하고 있었기 때문에, 다양한 방식을 찾은 거 같습니다.</p><p>어쨋든 Xcode-beta 또는 다른 버전의 Xcode 앱을 설치하고 <code>tuist edit</code> 명령어가 작동하지 않아서 당황하신 분들을 위해서 이 글을 적었습니다.</p><p>이 방식 외 더 좋은 방식에 대해서 알고 계신 분이 있다면, blog 댓글에 알려주세요.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/universal-framework</guid><title>Universal Framework</title><description>Universal Framework에 대한 공부</description><link>https://blog.jihoon.me/blog/universal-framework</link><pubDate>Sun, 2 Apr 2023 18:30:00 +0000</pubDate><content:encoded><![CDATA[<h2>Universal Framework (범용 프레임워크)</h2><p>디바이스와 시뮬레이터에서 사용가능하도록 범용적으로 프레임워크를 만드는 것입니다. <br/> Device에서의 OS, SimulatorOS 둘 모두에 적용하기 위해서는 Valid Architecture가 모두 존재해야합니다. iPhone OS에서의 CPU와, macOS에서의 경우 시뮬레이터의 구동을 위해서는 macOS의 CPU가 구현되어 맞춰줘야 합니다. <br/></p><p>이러한 문제점을 해결하기 위해서 나온 것이 Universal Framework입니다. <br/></p><h3>Universal Framework 의 장점</h3><ul><li>코드 재사용성이 올라간다.</li><li>코드 숨기가 쉬워진다.</li><li>코드 모듈화에 이점을 갖는다.</li><li>쉬운 통합이 가능하다.</li><li>쉽게 배포할 수 있다.</li></ul><h3>사용법</h3><p>Target 아래쪽에 있는 + 버튼을 누릅니다. 그 후 Other -&gt; Aggregate를 추가합니다. (Framework와 XCFramework 둘다 생성해줍니다.)</p><img width="100%" src="https://user-images.githubusercontent.com/68891494/230734262-75b7f72f-2fcb-4e3c-b4ab-540aef965dbe.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230734362-64553040-5617-4c18-88b3-fda6d5e38cdc.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230734363-8b0e9098-a026-4ed1-8ef8-aa298ecf3c5c.png"></img><br/><h2>Add Script</h2><p>각각의 Aggregate에 Script를 추가해줍니다.</p><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735301-2f7b56e2-f9d7-4265-b4a6-53f4faa975f2.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735305-e7f7eb72-bdec-4032-af50-554bdc78fafb.png"></img><h4>XCFramework</h4><pre><code># <span class="type">Build Device</span> and <span class="type">Simulator</span> versions
xcodebuild archive -scheme <span class="string">"${PROJECT_NAME}"</span> -archivePath <span class="string">"${BUILD_DIR}/iphoneos.xcarchive"</span> -sdk iphoneos <span class="type">SKIP_INSTALL</span>=<span class="type">NO BUILD_LIBRARY_FOR_DISTRIBUTION</span>=<span class="type">YES</span>
xcodebuild archive -scheme <span class="string">"${PROJECT_NAME}"</span> -archivePath <span class="string">"${BUILD_DIR}/iphonesimulator.xcarchive"</span> -sdk iphonesimulator <span class="type">SKIP_INSTALL</span>=<span class="type">NO BUILD_LIBRARY_FOR_DISTRIBUTION</span>=<span class="type">YES</span>

xcodebuild -create-xcframework \
    -framework <span class="string">"${BUILD_DIR}/iphoneos.xcarchive/Products/Library/Frameworks/"${PROJECT_NAME}".framework"</span> \
    -framework <span class="string">"${BUILD_DIR}/iphonesimulator.xcarchive/Products/Library/Frameworks/"${PROJECT_NAME}".framework"</span> \
    -output <span class="string">"${BUILD_DIR}/"${PROJECT_NAME}".xcframework"</span>

    
# <span class="type">Copy</span> the xcframework to the project directory
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/"${PROJECT_NAME}".xcframework" "${PROJECT_DIR}"</span>

# <span class="type">Open</span> the project directory <span class="keyword">in</span> <span class="type">Finder</span>
<span class="keyword">open</span> <span class="string">"${PROJECT_DIR}"</span>
</code></pre><h4>Framework</h4><pre><code><span class="type">UNIVERSAL_OUTPUTFOLDER</span>=${<span class="type">BUILD_DIR</span>}/${<span class="type">CONFIGURATION</span>}-<span class="type">Universal</span>
  
# <span class="type">Make</span> sure the output directory exists
mkdir -p <span class="string">"${UNIVERSAL_OUTPUTFOLDER}"</span>
  
# <span class="type">Build Device</span> and <span class="type">Simulator</span> versions
xcodebuild -target <span class="string">"${PROJECT_NAME}"</span> <span class="type">BITCODE_GENERATION_MODE</span>=bitcode <span class="type">OTHER_CFLAGS</span>=<span class="string">"-fembed-bitcode"</span> <span class="type">ONLY_ACTIVE_ARCH</span>=<span class="type">NO</span> -configuration ${<span class="type">CONFIGURATION</span>} -sdk iphonesimulator <span class="type">BUILD_DIR</span>=<span class="string">"${BUILD_DIR}"</span> <span class="type">BUILD_ROOT</span>=<span class="string">"${BUILD_ROOT}"</span> clean build
xcodebuild -target <span class="string">"${PROJECT_NAME}"</span> <span class="type">BITCODE_GENERATION_MODE</span>=bitcode <span class="type">OTHER_CFLAGS</span>=<span class="string">"-fembed-bitcode"</span> <span class="type">ONLY_ACTIVE_ARCH</span>=<span class="type">NO</span> -configuration ${<span class="type">CONFIGURATION</span>} -sdk iphoneos  <span class="type">BUILD_DIR</span>=<span class="string">"${BUILD_DIR}"</span> <span class="type">BUILD_ROOT</span>=<span class="string">"${BUILD_ROOT}"</span> clean build
  
  
# <span class="type">Copy</span> the framework structure (from iphoneos build) to the universal folder
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework" "${UNIVERSAL_OUTPUTFOLDER}/"</span>
  
# <span class="type">Copy Swift</span> modules from iphonesimulator build (if it exists) to the copied framework directory
cp -<span class="type">R</span> <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule/." "${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/Modules/${PROJECT_NAME}.swiftmodule"</span>
  
# <span class="type">Create</span> universal binary file using lipo and place the combined executable <span class="keyword">in</span> the copied framework directory
lipo -create <span class="string">"${BUILD_DIR}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework/${PROJECT_NAME}" "${BUILD_DIR}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework/${PROJECT_NAME}"</span> -output <span class="string">"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework/${PROJECT_NAME}"</span>
  
# <span class="type">Copy</span> the framework to the project directory
cp -<span class="type">R</span> <span class="string">"${UNIVERSAL_OUTPUTFOLDER}/${PROJECT_NAME}.framework" "${PROJECT_DIR}"</span>
  
# <span class="type">Open</span> the project directory <span class="keyword">in</span> <span class="type">Finder</span>
<span class="keyword">open</span> <span class="string">"${PROJECT_DIR}"</span>
</code></pre><br/><h2>Run</h2><img width="50%" src="https://user-images.githubusercontent.com/68891494/230735382-bb57dcae-094d-41fd-bbac-a67d58238720.png"></img><p>각각 원하는 Aggregate Scheme를 선택하고 빌드하면 됩니다.</p><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735710-e91d3125-07ac-4725-a878-64c378dcfa28.png"></img><img width="49%" src="https://user-images.githubusercontent.com/68891494/230735711-ad3a28d2-a6c9-4d8f-a44a-b6ac63ebfaa8.png"></img><p>좌 Framework Aggregate로 빌드 했을 때, 우 XCFramework Aggregate로 빌드 했을 때</p><br/><h2>Reference</h2><ul><li><a href="https://magicmon.tistory.com/225">tistory</a></li><li><a href="https://medium.com/macoclock/swift-universal-framework-3bc858224a7c">medium</a></li><li><a href="https://github.com/kstenerud/iOS-Universal-Framework">kstenerud/iOS-Universal-Framework</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/scade-introduce</guid><title>Scade 소개</title><description>Swift로 크로스플랫폼 만드는 방법을 아시나요?</description><link>https://blog.jihoon.me/blog/scade-introduce</link><pubDate>Fri, 17 Mar 2023 21:24:00 +0000</pubDate><content:encoded><![CDATA[<h2>What is Scade?</h2><p>Swift로 iOS 와 Android 개발을 동시에 할 수 있는 크로스 플랫폼입니다.</p><img width = 100% src = "https://user-images.githubusercontent.com/68891494/225908911-ad6d8638-99a4-496e-ad4e-ccc62238fe81.png"></img><p><a href="https://www.scade.io">scade.io</a></p><p>전용 툴을 제공하며, 위 <a href="https://www.scade.io/download/">링크</a>에서 다운 받을 수 있다. <br/> Scade의 <a href="https://docs.scade.io/docs">공식문서</a> 입니다.</p><hr><h3>어떻게 동작되는 걸까?</h3><p>Swift코드를 네이티브 iOS와 Android를 바이너리로 컴파일하여, 앱을 빌드합니다. <br/> 현재 기준 Scade는 Swift 5.4를 지원합니다.</p><img width = 100% src = "https://files.readme.io/448093c-scadecompiler.png"></img><p>위 링크를 통해 전용 툴을 다운로드 받았다면</p><img width=20% src = "https://user-images.githubusercontent.com/68891494/225911086-829ed397-231c-42f8-9286-30a14cea8887.png"></img><p>이러한 어플리케이션을 확인할 수 있을겁니다.</p><p>그리고 Xcode와 AndroidStudio 설치까지 마치셨다면, <a href="https://docs.scade.io/docs/getting-started">공식문서</a>를 보고 세팅해주시면 됩니다.</p><p><strong>중요</strong></p><img width=100% src = "https://files.readme.io/353f9ab-Screenshot_2022-10-20_at_09.51.18.jpeg"></img><p>이 부분의 세팅할 때 주의하시는 것이 좋습니다.</p><h3>프로젝트 생성하기</h3><p>IDE 내부에서 FILE| Name | New Project 로 프로젝트를 생성해줍니다.</p><img width=51% alt="스크린샷 2023-03-18 오후 3 38 06" src="https://user-images.githubusercontent.com/68891494/226089798-20eb3b08-1c00-4aef-9c32-88c18c04909e.png"></img><img width=39% alt="스크린샷 2023-03-18 오후 3 38 20" src="https://user-images.githubusercontent.com/68891494/226089897-4f4940d2-fc90-4e21-9da5-11f00456b2a4.png"></img><p>Scade IDE에서 프로젝트를 생성해주면 됩니다.</p><img width=30% src = "https://user-images.githubusercontent.com/68891494/226188230-d29f816d-d73a-42b0-803d-ec8498550584.png"></img><p>Scade같은 경우 3가지 종류의 로 빌드가 가능합니다. <br/> 자체 시뮬레이터인 Scade Simulator, iOS의 Simulator, Android Emulator</p><p>뷰 같은 경우 .page 파일에서 스토리보드와 비슷하게 되어 있는것을 확인 할 수 있고,</p><img width = 100% src = "https://user-images.githubusercontent.com/68891494/226189250-92402bc0-7f11-428a-bbea-af726f0136b3.png"></img><p>우측 + 버튼을 눌러서 Component를 가져올 수 있습니다.</p><img width = 40% src = "https://user-images.githubusercontent.com/68891494/226189421-2d4ff86a-4841-4091-9b52-11c74ecb27d1.png"></img><p>원하는 컴포넌트를 Drag &amp; Drop 해주면 됩니다. (Storyboard와 같은 느낌이죠?)</p><img width=80% src = "https://user-images.githubusercontent.com/68891494/226189572-c1c21fb6-0568-4466-9aed-8877b4c1f87a.png"></img><p>Scade IDE 우측에 있는 옵션들을 수정하여, Component를 설정 할 수도 있습니다.</p><h3>실행</h3><p>한번 Android와 iOS에서 잘 돌아가는지 확인해 보겠습니다.</p><img width=100% src = "https://github.com/jihoonahn/blog/assets/68891494/eddc178e-3b54-431d-8931-6b73c77fe6f6"></img><p>좌 iOS Simulator, 우 Android Emulator</p><p>같은 UI로 잘 돌아가는 것을 확인 할 수 있습니다.</p><h3>Scade를 사용해보고 느낀점</h3><p>현재 꾸준히 개발되고 있지만 현재는 Beta 버전이고, 현재 공개된 <a href="https://github.com/scade-platform">Scade Platform Github</a>는 이곳입니다. 아쉽게도 Scade SDK는 오픈소스는 아니기 때문에 뭔가 아쉽다 라는 느낌을 받긴 했지만, Swift로 iOS, Android CrossPlatform 개발이 된다는 점에서 신기한 느낌을 받고, IDE에서 Storyboard와 같은 기능을 지원하는것도 신기했습니다.</p><p>아직 부족한 부분은 분명 있지만 현재 베타버전임을 감안하고, 몇년에 걸쳐서 개발이 되는것을 보아, <br/> 추후 정식 출시날도 기다려집니다.</p><p>제가 개인적으로 느낀 점은, 그저 신기하다에 그치지 않고 Scade는 생각보다 놀라운 도구 였습니다. <br/></p><p>저의 주 언어인 Swift를 가지고 Android 와 iOS를 동시 개발 가능하게 해주기 때문에, 저에게는 큰 흥미를 주었던 것 같습니다.</p><p>현재 Scade의 미래가 어떻게 될지 모르지만 Scade는 Beta에서만 끝나지 않고, 늦어도 좋으니 정식 출시까지 했으면 좋겠다는 생각이 들었습니다. (추후 Apple에서 비슷한 걸 제공해도 좋고요 ㅎㅎ)</p><hr><br/><p>이번에는 Scade에 대해서 소개하는 글이기 때문에, 간단하게 소개했기 때문에 여기에서 글을 끝내고 <br/> 나중에 Scade를 더 깊게 사용해보며, 글을 적도록 하겠습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/yackety-yak-ios-4</guid><title>와글와글 제4회 발표 회고록</title><description>와글와글 iOS 제 4회 발표 회고</description><link>https://blog.jihoon.me/blog/yackety-yak-ios-4</link><pubDate>Sat, 11 Feb 2023 05:25:00 +0000</pubDate><content:encoded><![CDATA[<iframe src="https://www.youtube.com/embed/rDlcnt31re0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p>이번 제 4회 와글와글 iOS에서 블로깅하는 방법에 대해서 발표를 했고, 이에 대한 회고 입니다. <br/><br/></p><h2>발표 준비</h2><p>발표 전 당시 저는 Publish에 관심도가 높아졌고, 다른 사람들에게 Publish 사용을 권하고 있었을 때 <br/> 리이오님이 감사하게도 발표를 제안을 주셔서 "Swift로 블로깅하기" 라는 주제로 발표를 하게 되었습니다. <br/></p><p>저의 첫 발표였기 때문에, 어떻게 준비해야하나 부터 고민하고, 발표를 어떻게 해야는지 고민을 했던 것 같습니다. <br/></p><p>미리 발표 자료를 만들기 위해서 Keynote내에서 어떤 목차로 진행 해야할지 부터 고민을 했습니다. <br/></p><pre><code>- 다른 <span class="type">Swift</span> 로 웹을 만드는 라이브러리와 비교
- <span class="type">Publish</span> 에 대한 소개 (소개 &amp; 특징)
- <span class="type">Publish</span> 설치
- <span class="type">Publish</span> 시작하기
- 어떤 결과물이 나올까
- 글 작성 방법
- 커스텀 하는 방법 
- <span class="type">Publish</span> 로 만들어진 <span class="type">Web</span> 들 예시
- 한계점
- 장점
- 느낀점
- 하고 싶은말
</code></pre><p>이런 목차로 진행하기로 정하고 발표 세부 내용을 작성하였습니다.<br/></p><img width="48.25%" src="https://user-images.githubusercontent.com/68891494/229304866-8fb2c86f-efec-4e13-a649-0c0a6ec6d44f.png"></img><img width="48%" src="https://user-images.githubusercontent.com/68891494/229304874-9710b33b-bea3-41f8-922b-d6573346f8d4.png"></img><p>이번 발표에서는 "왜 Publish인가?" 라는 것에 대한 저의 의견이 담는 것이 중요했습니다. <br/></p><p>또한 잘못된 내용을 전달하면 안되기 때문에, 반복적으로 검토하고 수정하기를 진행하였고, 발표 주제가 마이너한 라이브러리를 소개하기 때문에, Publish에 대한 대략적인 부분에 대한 설명부터 해야하기 때문에, 사람들에게 이해시키는 부분도 필요했고, 어떻게 사용할지에 대한 설명도 필요했습니다. <br/></p><p>이런 부분을 생각하다보니 Keynote의 내용이 너무 많아졌고, 발표 주제에 맞는 방향인 간단하게 소개하는 방식으로 바꾸기로 결정하였습니다. <br/></p><p>그리고 blog의 대부분 소스를 공개하지 않았기 때문에 너무 레퍼런스가 부족한 상황이였고, 처음 시작하는 사람들이 쉽게 이해할 수 있도록 레퍼런스 마련을 위해서 여러번의 고민 끝에 제가 직접 만든 블로그를 Public으로 공개하기로 결정하였습니다. <br/><br/></p><h2>발표 당일</h2><p>대망의 발표날이 찾아왔고, 저녁 7시 부터 발표를 시작할 준비를 하였습니다. 아침에 몇번 다시 내용을 확인하고, 발표에 대비를 하였으나, 점점 긴장을 하게되었습니다. 발표하기 10분 전에 미리 디스코드 방에 들어가서, 미리 대기를 하였습니다.</p><h2>발표 시작</h2><p>처음 진행을 할 때 8명으로 시작을 하였고, 추가적으로 3~4명 이상 진행 중에 들어오셨습니다. <br/> 발표 진행을 시작하자마자 문제가 발생했습니다.. 😓 <br/> 첫 발표인 이유도 있었지만, 발표를 많이 해보지 않았기 때문에 너무 긴장해버렸습니다.. <br/> 제가 너무 긴장해버린 나머지, 목소리도 잘 안나오고, 머리에서는 "아 망했다" 라는 생각이 들어서 추가적으로 더 긴장을 해버렸던 것 같습니다 ㅋㅋ.. <br/></p><p>정신 없이 발표가 진행되고, 하나의 걱정이 머리를 스쳐갔습니다. <br/></p><blockquote><p>"과연 발표 내용이 잘 전달 되었을까?"</p></blockquote><p>가장 발표에서 중요한 부분이지만, 다른 분들도 Publish를 한번 씩 사용해보겠다 라는 말을 듣고, 그래도 어느정도 발표에서 말하고 싶은 부분은 전달이 됬구나 라고 생각이 되서 다행이라고 생각이 들었습니다. <br/><br/></p><h2>발표가 끝나고</h2><p>제가 느끼기에는 아주 긴 발표시간이 지나가고, 개인적으로 긴장해버린 것 때문에 걱정을 많이 했고, 많은 아쉬움이 남았습니다. <br/> 그래도 첫 발표를 끝냈다는 생각에 저에게 어떤 부분이 부족하고, 나중의 발표에서 어떤 부분을 주의해야할 지도 알게되는 시간이였습니다. <br/></p><img width="50%" src="https://user-images.githubusercontent.com/68891494/229306762-6f3d2cfb-d7fc-47aa-9146-c5fea892c778.png"></img><p>리이오님이 좋은 자리를 마련해주셔서, 좋은 경험이 됬습니다. (감사합니다.. 🙏) <br/><br/></p><h2>느낀점</h2><p>이번에 발표를 해보고, 다른 곳에서도 발표를 해보고 싶다는 생각을 하게 되었습니다. <br/> 비록 이번에는 많은 부분이 부족했지만, 내가 알고 있는 것을 다른 사람과 공유하는 것에 대한 재미를 느끼게 되었고, 현재 발표에서 부족한 부분을 해결하기 위해서 더 많은 곳에서 발표하고 싶다는 생각을 하게 되었습니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/what-is-swiftui</guid><title>SwiftUI 소개</title><description>선언형 UI로 생산성을 높여주는 SwiftUI에 대한 설명입니다.</description><link>https://blog.jihoon.me/blog/what-is-swiftui</link><pubDate>Thu, 20 Oct 2022 17:02:00 +0000</pubDate><content:encoded><![CDATA[<iframe src="https://www.youtube.com/embed/psL_5RIBqnY?start=7603" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p><strong>본 영상은 WWDC 19이며 SwiftUI 소개되는 부분에서 시작이됩니다.</strong></p><p>2019년 애플의 WWDC에서 처음 소개된 SwiftUI 는 모든 애플 운영체제용 앱을 개발하는데 있어서 완전히 새로운 방법을 제공합니다.</p><p>SwiftUI의 기본적인 목적은 앱 개발을 더 쉽고 폭발적인 생산성을 내면서 동시에 소프트웨어를 개발할 때 일반적으로 발생하는 버그들을 줄이는 것입니다. <br/> 또한 개발 과정에서도 앱의 라이브 프리뷰 기능을 이용하여 SwiftUI 프로젝트를 실시간으로 테스트할 수 있게 합니다. <br/></p><img width="100%" src="https://user-images.githubusercontent.com/68891494/229286766-44425ba2-bc64-4955-b106-99d99904313f.png"></img><p>위 이미지는 SwiftUI Project를 생성했을 때의 모습입니다. <br/><br/></p><h2>SwiftUI의 선언적 구문</h2><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Text</span>(<span class="string">"Hello, world!"</span>)
                .<span class="call">frame</span>(maxWidth: .<span class="dotAccess">infinity</span>, maxHeight: .<span class="dotAccess">infinity</span>)
                .<span class="call">foregroundColor</span>(.<span class="dotAccess">white</span>)
        }
        .<span class="call">padding</span>()
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>UIKit과 인터페이스 빌더를 User Interface Layout을 설계하고 필요한 동작을 구현하는 것과는 완전히 다른 방법인 선언적 구문(declairactive syntax)이 SwiftUI에 도입되었습니다. <br/> 이 과정에서 기본적으로 레이아웃에 포함될 컴포넌트들을 선언하고, 그것들이 포함될 레이아웃 메니지 종류 (VStack, HStack, Form, List 등)를 명시하고, 속성을 설정하기 위해 수정자(modifier)를 사용합니다. <br/> 이렇게 선언하고 난 후 레이아웃의 위치와 constraint그리고 렌더링 방법에 대한 모든 복잡한 세부 사항은 SwiftUI가 자동으로 처리합니다. <br/> SwiftUI 선언은 계층적으로 구조화 되어 있습니다. 따라서 복잡한 뷰를 보다 쉽게 생성할 수 있습니다. <br/> <br/></p><h2>SwiftUI는 데이터 주도적</h2><p>SwiftUI 이전에는 앱 내에 있는 데이터의 현재 값을 검사하려면 그에 대한 코드를 앱에 포함 해야했습니다. <br/> 시간에 지남에 따라 데이터가 변한다면 사용자 인터페이스가 데이터의 최신 상태를 항상 반영하도록 하는 코드를 작성하거나, 데이터가 변경되었는지 주기적으로 검사하는 코드를 작성하는 것, 그리고 갱신 메뉴를 제공 해야했습니다. <br/> 이러한 데이터 소스를 앱의 여러 영역에서 사용할 경우 소스 코드의 복잡도가 증가합니다. <br/></p><blockquote><p><strong>SwiftUI는 앱의 데이터 모델과 사용자 인터페이스 컴포넌트, 그리고 기능을 제공하는 로직을 binding하는 여러방법으로 복잡도를 해결하게 됩니다.</strong> <br/></p></blockquote><p>데이터 주도로 구현하면 데이터 모델은 앱의 다른 부분에서 subscibe 할 수 데이터 변수는 publish 하게 됩니다. (publisher – subsciber) <br/> 이러한 방법을 통해 데이터가 변경되었다는 사실을 모든 구독자에게 자동으로 알릴 수 있습니다.<br/> 만약 사용자 인터페이스 컴포넌트와 데이터 모델 간에 바인딩이 된다면, <strong>추가적인 코드를 작성하지 않아도 모든 데이터의 변경 사항을 SwiftUI가 사용자 인터페이스에 자동으로 반영할 것</strong>입니다. <br/><br/></p><h2>UIKit VS SwiftUI</h2><img width="100%" src = "https://res.cloudinary.com/practicaldev/image/fetch/s--Ry1DiaP7--/c_imagga_scale,f_auto,fl_progressive,h_900,q_auto,w_1600/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/85fmihrdl249k9cuid1i.png"></img><p><strong>UIKit</strong></p><pre><code><span class="keyword">import</span> UIKit

<span class="keyword">final class</span> ViewController: <span class="type">UIViewController</span> {
     
    <span class="keyword">private lazy var</span> button: <span class="type">UIButton</span> = {
        <span class="keyword">let</span> button = <span class="type">UIButton</span>()
        button.<span class="call">setTitle</span>(<span class="string">"Hello UIKit"</span>, for: .<span class="dotAccess">normal</span>)
        button.<span class="call">addTarget</span>(<span class="keyword">self</span>, action: <span class="keyword">#selector</span>(helloUIKitButtonAction), for: .<span class="dotAccess">touchUpInside</span>)
        <span class="keyword">return</span> button
    }()
    
    <span class="keyword">override func</span> viewDidLoad() {
        <span class="keyword">super</span>.<span class="call">viewDidLoad</span>()
        
        view.<span class="property">backgroundColor</span> = .<span class="dotAccess">black</span>
        
        view.<span class="call">addSubview</span>(button)
        
        <span class="type">NSLayoutConstraint</span>.<span class="call">activate</span>([
            button.<span class="property">centerXAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerXAnchor</span>),
            button.<span class="property">centerYAnchor</span>.<span class="call">constraint</span>(equalTo: <span class="keyword">self</span>.<span class="property">view</span>.<span class="property">centerYAnchor</span>)
        ])
    }
    
    <span class="keyword">@objc private func</span> helloUIKitButtonAction() {
        <span class="call">printContent</span>(<span class="string">"Hello UIKit!"</span>)
    }
}
</code></pre><p><strong>SwiftUI</strong></p><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> ContentView: <span class="type">View</span> {
    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">VStack</span> {
            <span class="type">Button</span>(<span class="string">"Hello SwiftUI"</span>) {
                <span class="call">print</span>(<span class="string">"Hello SwiftUI!"</span>)
            }
        }
        .<span class="call">background</span>(.<span class="dotAccess">black</span>)
    }
}
</code></pre><p>같은 동작을 하는 뷰를 만들어 봤습니다. <br/></p><p>차이점이 보이시나요? UIKit(명령형)과 SwiftUI(선언형)을 비교해볼 때 <br/></p><p>UIKit에서는 Property를 선언 view에 추가하고, Layout에 제약사항을 준 후, action을 할 함수를 만들어서 button에 addTarget 해줍니다. <br/></p><p>하지만 SwiftUI에서는 그래로 원하는 위치에 Button을 추가하고 action을 추가하면 끝납니다. <br/></p><p>생산성 부분에서 어마어마하게 차이가 난다는 걸 볼 수 있습니다. <br/><br/></p><h2>UIKit과 SwiftUI를 함께 사용하는 방법</h2><p>사실 UIView와 SwiftUI를 함께 사용할 수 있는 방법은 다양하게 존재합니다. <br/></p><p>SwiftUI는 빠르고 효율적인 앱 개발 환경을 제공할 뿐만 아니라 코드를 크게 변경하지 않아도 다양한 애플 플랫폼에서 동일한 앱을 사용할 수 있게 합니다.<br/></p><p>하지만 지도 또는 웹 뷰를 통합해야 하는 특정 기능은 여전히 UIKit을 사용해야 하고, 매우 복잡한 UI 레이아웃을 설계하는 경우에 SwiftUI 레이아웃 컨테이너 뷰 사용이 만족스럽지 않을 수 있습니다. <br/></p><p>이런 상황에서는 인터페이스 빌더를 사용을 하는 방식으로 해결할 수도 있습니다. <br/><br/></p><h2>지금 SwiftUI는 어떨까?</h2><p>현재까지는 시기상조라는 말도 있고, 회사에서 도입 할 것이라는 말이 있습니다. <br/> 이 부분은 사람마다 의견이 다르기 때문에 정확한 대답은 어렵지만, 개인적으로 저는 자신이 처한 상황에서 직접 고려하여 결정하는 것이 좋다고 생각합니다. <br/></p><p>SwiftUI 최소 버전은 iOS 기준 13.0이지만, 제대로 사용하려면 15.0 이상이여야 하기 때문에, 이러한 부분은 좀 많이 아쉽긴 합니다. <br/></p><p>그리고 현재 SwiftUI는 버그도 있기도 하고, 아직 사용하기에는 불완전하다는 말에 동의는 합니다. <br/> 하지만 엄청난 생산성을 갖는다는것, 그리고 Apple이 추구하는 방향성의 UI Framework라는 것은 부정할 수 없기 때문에, iOS 개발자로 살면 언젠가는 사용해야하기 때문에 미리 공부해 보는 것도 좋다고 생각을 합니다.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/swiftui-need-mvvm</guid><title>SwiftUI에 MVVM이 필요할까요?</title><description>요즘 이슈가 되고 있는 내용으로, 과연 SwiftUI에는 MVVM이 필요한지에 대한 저의 주관적인 생각을 담은 글입니다.</description><link>https://blog.jihoon.me/blog/swiftui-need-mvvm</link><pubDate>Wed, 21 Sep 2022 12:00:00 +0000</pubDate><content:encoded><![CDATA[<h2>SwiftUI MVVM issue?</h2><img width = 100% src = "https://github.com/Jihoonahn/Blog/assets/68891494/cb143b4f-90af-499b-9cd9-6fa2e6ede38c"></img><p><a href="https://developer.apple.com/forums/thread/699003">Stop using MVVM for SwiftUI (apple developer forms)</a> <br/> <a href="https://medium.com/@karamage/stop-using-mvvm-with-swiftui-2c46eb2cc8dc">Stop using MVVM with SwiftUI (medium post)</a></p><p>위 글을 보면 SwiftUI에서 MVVM 사용을 멈추자는 의견을 제시하고 있습니다.</p><p>“SwiftUI에서 MVVM 사용 중지”라는 강력한 주제로 저의 관심을 끌었습니다.</p><p>글은 꽤나 논리적인 글이라고 생각이 되었습니다. SwiftUI내에서 MVVM의 사용을 의심하지 않았던 저에게는 진짜 많은 생각을 하게 만들었었습니다.</p><img width = 100% src = "https://github.com/Jihoonahn/Blog/assets/68891494/ad50e41a-aacd-4e00-a7ce-c747beeb731b"></img><p><a href="https://www.reddit.com/r/swift/comments/m60pv7/is_mvvm_an_antipattern_in_swiftui/">Is MVVM an anti-pattern in SwiftUI?</a></p><p>Reddit에서도 issue가 된 내용입니다.</p><br/><h3>여기서부터는 저의 생각이 들어갔습니다.</h3><p>SwiftUI는? 선언형 뷰 프로그래밍 방식입니다.</p><p><strong>선언형 UI에서는 ViewModel은 필요할까</strong> 라는 주제의 여러 글들을 보고 따로 공부와 여러가지 생각을 했습니다.</p><p>옛날에는 “MVVM이 무조건 좋다” 라는 인식이 존재했습니다. 그런데 SwiftUI로 개발을 하면서 억지로 ViewModel을 만드는 상황이 발생하고 있습니다.</p><p>ViewModel은 비즈니스 로직을 분리하는 목적으로 사용할 수 있기 때문에 ViewModel이 완전히 나쁘다 라고 하기는 어려울것 같습니다.<br>하지만 저는 SwiftUI의 View는 이미 View + ViewModel라고 생각하기 때문에 저는 불필요하다고 생각합니다.<br><br/></p><h3>SwiftUI에서의 View는 이미 View+ViewModel 입니다.</h3><pre><code><span class="keyword">import</span> SwiftUI

<span class="keyword">struct</span> Content: <span class="type">View</span> {
    <span class="keyword">@State var</span> model = <span class="type">Themes</span>.<span class="property">listModel</span>

    <span class="keyword">var</span> body: <span class="keyword">some</span> <span class="type">View</span> {
        <span class="type">List</span>(model.<span class="property">items</span>, action: model.<span class="property">selectItem</span>) { item <span class="keyword">in</span>
            <span class="type">Image</span>(item.<span class="property">image</span>)
            <span class="type">VStack</span>(alignment: .<span class="dotAccess">leading</span>) {
                <span class="type">Text</span>(item.<span class="property">title</span>)
                <span class="type">Text</span>(item.<span class="property">subtitle</span>)
                    .<span class="call">color</span>(.<span class="dotAccess">gray</span>)
            }
        }
    }
}
</code></pre><p>medium 블로그 글의 예시를 가져왔습니다.</p><p>예시처럼 SwiftUI의 View는 원래부터 데이터 바인딩 기능을 포함하고 있기 때문에, 모델 값을 View에 직접 Reactive하게 반영 할 수 있습니다.</p><p>ViewModel은 원래 상태를 View에 Binding하여 Reactive에 반영하기 위한 목적으로 도입되었습니다.</p><p>하지만 위 예시처럼 선언적 UI에는 해당 기능이 포함되어 있으므로 ViewModel은 필요하지 않다고 생각합니다.</p><br/><h3>우리가 왜 MVVM이 무조건 좋다고 생각했을까요?</h3><p>이것은 기존 사용했던 UIKit을 보고 알 수 있었습니다.</p><p>기존 코드에서는 rx를 통해 데이터 바인딩을 해주는 코드를 사용했습니다. (RxSwift를 사용했을 때) 흔하게 알고 있는 ViewModel을 통해서 뷰와 데이터 바인딩을 해주는 MVVM 구조입니다.</p><p>ViewModel의 가장 중요한 역할은 데이터 바인딩입니다. 모델과 뷰 사이에 양방향 통신을 해주면서 바인딩을 시켜줍니다.</p><p><strong>하지만 SwiftUI에서는 View에서 다 해줄 수 있기 때문에 필요가 없다는 생각이 됩니다.</strong></p><br/><h3>SwiftUI에 MVVM을 사용하는 것은 복잡도를 올리게 됩니다.</h3><p>SwiftUI에서 MVVM을 사용하게 되면, ViewModel이라는 레이어가 추가되기 때문에 복잡도가 증가합니다.</p><p>또한 Data Flow는 ViewModel이 View와 Model의 중간 레이어와 함께 배치되어서 양방향으로 동작하게 됩니다.</p><img width="100%" alt="my-option" src="https://user-images.githubusercontent.com/73165292/196845240-6b0ed156-f79f-4d70-9b13-fcabe343725b.png">
</img><p><a href="https://developer.apple.com/documentation/swiftui/model-data">Apple Document</a></p><p><strong>선언형 UI를 사용하는 환경에서는 단방향 데이터 플로우 구조를 지향합니다.</strong></p><p>현재 많은 개발자들이 아키텍처 패턴으로 MVVM을 사용합니다.</p><p>많은 자료들이 SwiftUI + MVVM을 사용하는 방법에 대해서 설명을 하고 있기도 합니다.</p><br/><h2>이미 Vue나 React, Flutter 모두 MVVM을 사용하고 있지 않습니다.</h2><p>세가지의 모두 공통점으로 선언형 UI를 사용한다는 것을 알 수 있습니다.</p><p>그러면 MVVM 말고 SwiftUI에서 무엇을 사용해야 할까요?</p><h3>그럼 뭘 사용하라는 건가</h3><p>ViewModel을 사용하지 않는다면 비즈니스 로직과 UI 로직을 어떻게 어디서 분리해야 할까요?</p><p><a href="https://www.youtube.com/watch?v=mTv96vqTDhc&t=756s">Realm</a>에서는 MVI 접근 방식을 지향한다고 합니다.</p><p>3가지 방법을 생각해볼 수 있습니다.</p><ol><li>Model에서 이를 구현한다. (MV)</li><li>MVI (Model-View-Intent)</li><li>Flux 개념의 Store로 분리한다.</li></ol><p>첫번째 방법은 선언적 UI에 어울리는 단방향 플로우의 장점을 챙겨가지 못하기 때문에 적합하지 않고,</p><p>그렇기 때문에 MVI 와 Flux 및 Store/Provider 패턴이 적합하다고 생각합니다.</p><hr><p>저는 이 논쟁에 대해 저의 생각을 답글에 달았습니다.</p><img width="100%" alt="my-option" src="https://user-images.githubusercontent.com/73165292/196845524-2621e870-0fc8-4caf-b636-34aa2a452be9.png">
</img>]]></content:encoded></item><item><guid isPermaLink="true">https://blog.jihoon.me/blog/what-is-swift</guid><title>Swift란?</title><description>Swift 언어에 대한 소개입니다.</description><link>https://blog.jihoon.me/blog/what-is-swift</link><pubDate>Sun, 11 Apr 2021 07:02:00 +0000</pubDate><content:encoded><![CDATA[<p><a href="https://developer.apple.com/swift/">Apple 공식 Swift</a></p><p>스위프트는 iOS, macOS, watchOS, tvOS를 개발하기 위해 애플에서 제공하는 프로그래밍 언어 입니다.</p><h3>Swift의 특징</h3><p>애플이 최초에 스위프트를 발표했을 때 스위프트 언어의 특성을 Safe, Modern, Powerful 이라고 발표했습니다. 그러나 오픈소스로 전환되면서 특징을 Safe, Fast, Expressive로 변경하여 발표했습니다. 더불어 애플은 ‘스위프트는 보다 직관적이고 배우기 쉬운 언어’라고 스위프트를 소개했습니다. 먼저 애플이 발표한 스위프트의 언어적 특성을 항목별로 정리해 보았습니다.</p><h3>Safe</h3><p>스위프트는 안전한 프로그래밍을 지향합니다.</p><p>소프트웨어가 배포되기 전에, 즉 프로그래밍을 하는 중에 프로그래머가 저지를 수 있는 실수를 엄격한 문법을 통하여 미연에 방지하고자 노력했습니다. 때론 너무 강제적이라고 느껴질 수 있지만 문법적 제재는 실수를 줄이는 데 도움이 됩니다. 버그를 수정하거나 실수를 찾아내는 시간을 절약할 수 있습니다.</p><p>옵셔널이라는 기능을 비롯하여 guard 구문, 오류처리, 강력한 타입통제 등을 통해 스위프트는 안전한 프로그래밍을 구현하고 있습니다.</p><h3>Fast</h3><p>스위프트는 C 언어를 기반으로 한 C, C++, Objective-C와 같은 프로그래밍 언어를 대체하려는 목적으로 만들어졌습니다. 아직은 부분적으로 미흡하지만 성능 또한 C 언어 수준을 목표로 개발되었습니다. 그래서 스위프트는 성능을 예측할 수 있고 일정한 수준으로 유지할 수 있는 부분에 초점을 맞춰 개발되었습니다.</p><p>실행속도의 최적화 뿐만 아니라 컴파일러의 지속된 개량을 통해 더 빠른 컴파일 성능을 구현해 나가고 있습니다.</p><h3>Expressive</h3><p>스위프트는 여러 가지 프로그래밍 패러다임을 채용한 다중 패러다임 프로그래밍 언어입니다. 크게 보면 스위프트는 명령형 프로그래밍 패러다임, 객체지향 프로그래밍 패러다임, 함수형 프로그래밍 패러다임, 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 정확하게는 명령형과 객체지향 프로그래밍 패러다임을 기반으로 한 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임을 지향합니다. 결과적으로 스위프트에서 가장 강조하는 부분은 함수형 프로그래밍 패러다임과 프로토콜 지향 프로그래밍 패러다임입니다.</p><p>기존의 C 언어는 명령형 혹은 절자적 프로그래밍 패러다임을 채용했으며, C++, Java 등의 언어는 명령형 프로그래밍 패러다임과 객체지향 프로그래밍 패러다임을 동시에 채용한 다중 프로그래밍 패러다임 언어입니다.</p><p>최신 업데이트는 <a href="https://github.com/apple/swift/releases/tag/swift-5.7-RELEASE">5.7</a>입니다.</p><h2>Xcode Start</h2><p>Xcode는 iOS App 개발을 위한 IDE(통합 개발 환경, Integrated Development Environment) 입니다. iOS 뿐만 아니라 macOS, iPadOS, tvOS, watchOS... 등등 다양판 플랫폼을 제공할 수 있다.</p><p><a href="https://apps.apple.com/kr/app/xcode/id497799835?mt=12">AppStore</a></p><p>또는</p><p>명령어를 통해서 설치할 수 있습니다.</p><pre><code>xcode-select --install
</code></pre>]]></content:encoded></item></channel></rss>